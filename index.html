<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<title>Build Cache Practices</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
<link rel="stylesheet" href="https://guides.gradle.org/asciidoctor.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,400,700|Source+Code+Pro:500">
<link rel="apple-touch-icon" sizes="180x180" href="https://guides.gradle.org/icon/apple-touch-icon.png">
<link rel="icon" type="image/png" href="https://guides.gradle.org/icon/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="https://guides.gradle.org/icon/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="https://guides.gradle.org/icon/manifest.json">
<link rel="mask-icon" href="https://guides.gradle.org/icon/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="https://guides.gradle.org/icon/favicon.ico">
<meta name="apple-mobile-web-app-title" content="Build Cache Practices">
<meta name="application-name" content="Build Cache Practices">
<meta name="msapplication-config" content="https://guides.gradle.org/icon/browserconfig.xml">
<meta name="theme-color" content="#ffffff">
<script defer src="https://guides.gradle.org/js/set-time-to-complete-text.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i["GoogleAnalyticsObject"]=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,"script","https://www.google-analytics.com/analytics.js","ga");
  ga("create", "UA-4207603-1", "auto");
  ga("send", "pageview");
</script>
</head>
<body class="article toc2 toc-right">
<div id="header"><div style="padding-top: 10px;"><a href="https://guides.gradle.org"><img src="http://guides.gradle.org/gradle-guides.svg" alt=""></a></div><h1>Build Cache Practices</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#use_cases_for_the_build_cache">1. Use cases for the build cache</a>
<ul class="sectlevel2">
<li><a href="#speed_up_developer_builds_with_the_local_cache">1.1. Speed up developer builds with the local cache</a></li>
<li><a href="#share_results_between_ci_builds">1.2. Share results between CI builds</a></li>
<li><a href="#accelerate_developer_builds_by_reusing_ci_results">1.3. Accelerate developer builds by reusing CI results</a></li>
<li><a href="#combine_ci_results_with_local_caching_on_developer_machines">1.4. Combine CI results with local caching on developer machines</a></li>
<li><a href="#share_results_between_developers">1.5. Share results between developers</a></li>
</ul>
</li>
<li><a href="#important_concepts">2. Important concepts</a>
<ul class="sectlevel2">
<li><a href="#repeatable_task_outcomes">2.1. Repeatable task outcomes</a></li>
<li><a href="#stable_task_inputs">2.2. Stable task inputs</a></li>
<li><a href="#normalization">2.3. Better reuse via input normalization</a></li>
<li><a href="#the_case_against_overlapping_outputs">2.4. The case against overlapping outputs</a></li>
</ul>
</li>
<li><a href="#debugging_and_diagnosing_cache_misses">3. Debugging and diagnosing cache misses</a>
<ul class="sectlevel2">
<li><a href="#how_to_find_problems_with_task_output_caching">3.1. How to find problems with task output caching</a></li>
<li><a href="#helpful_data_for_diagnosing_a_cache_miss">3.2. Helpful data for diagnosing a cache miss</a></li>
<li><a href="#diagnosing_the_reasons_for_a_cache_miss">3.3. Diagnosing the reasons for a cache miss</a></li>
<li><a href="#example">3.4. Example</a></li>
</ul>
</li>
<li><a href="#common_problems_and_their_solutions">4. Common problems and their solutions</a>
<ul class="sectlevel2">
<li><a href="#system_file_encoding">4.1. System file encoding</a></li>
<li><a href="#environment_variable_tracking">4.2. Environment variable tracking</a></li>
<li><a href="#line_endings">4.3. Line endings</a></li>
<li><a href="#symbolic_links">4.4. Symbolic links</a></li>
<li><a href="#java_version_tracking">4.5. Java version tracking</a></li>
<li><a href="#avoid_changing_inputs_external_to_your_build">4.6. Avoid changing inputs external to your build</a></li>
<li><a href="#suggestions_for_authoring_your_build">4.7. Suggestions for authoring your build</a></li>
<li><a href="#volatile_data">4.8. Volatile data in build artifacts</a></li>
<li><a href="#custom_and_third_party_tasks">4.9. Custom and third party tasks</a></li>
</ul>
</li>
<li><a href="#summary">5. Summary</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The best way to do work faster is to not do work that doesn’t need doing. Gradle has two main mechanisms to avoid work at the task level:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>incremental build</strong> avoids running a task if its inputs and outputs are equivalent to what they were during its previous execution,</p>
</li>
<li>
<p><strong>task output caching</strong> reuses task outputs produced with the same inputs anytime before, on any machine that is connected to the same build cache backend.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This guide covers the different use cases for Gradle’s build cache, from local-only development to caching task outputs across large teams. We will discuss ways to measure the advantages provided by the build cache, and methods to improve cache performance, or to diagnose and fix common problems. Let’s dive in!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="use_cases_for_the_build_cache"><a class="anchor" href="#use_cases_for_the_build_cache"></a>1. Use cases for the build cache</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gradle’s build cache is a versatile feature that can be used in different ways.</p>
</div>
<div class="sect2">
<h3 id="speed_up_developer_builds_with_the_local_cache"><a class="anchor" href="#speed_up_developer_builds_with_the_local_cache"></a>1.1. Speed up developer builds with the local cache</h3>
<div class="paragraph">
<p>Even when used by a single developer only, the build cache can be pretty useful. Gradle&#8217;s <em>incremental build</em> feature helps avoid work that is already done, but once you change the inputs of a task, it forgets any previous results. When you are switching branches back and forth, the local results get rebuilt over and over again, even if you are building something that has already been built before. The build cache remembers, though, and heavily reduces the need to rebuild things when they were already built locally. In general it&#8217;s very useful when you need to rebuild different commits, like when running <code>git bisect</code>.</p>
</div>
<div class="paragraph">
<p>The local cache can also be useful when working with a project that has multiple variants dimensions, like in the case of Android applications. Each variant has a number of tasks associated with it, and some of those task variants, despite having different names, can end up doing the same things. With the local cache enabled reuse between task variants will happen automatically when applicable.</p>
</div>
</div>
<div class="sect2">
<h3 id="share_results_between_ci_builds"><a class="anchor" href="#share_results_between_ci_builds"></a>1.2. Share results between CI builds</h3>
<div class="paragraph">
<p>The build cache can do more than going back-and-forth in time: it can also bridge physical distance between computers, allowing to reuse results generated on one machine to be reused by another.</p>
</div>
<div class="paragraph">
<p>A usual first step when introducing the build cache within a team is to enable it for CI builds only. Using a shared HTTP build cache backend (such as <a href="https://gradle.com/build-cache/">the one provided by Gradle Enterprise</a> can significantly reduce the work CI executors need to do. This translates into faster feedback to developers, and less money spent on the CI infrastructure.</p>
</div>
<div class="paragraph">
<p>Using the build cache on CI first makes sense as CI environment is usually easier to control than developer machines. It helps shake out issues with the build that hurt cacheability.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>TODO:</strong> Discus audit requirements.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="accelerate_developer_builds_by_reusing_ci_results"><a class="anchor" href="#accelerate_developer_builds_by_reusing_ci_results"></a>1.3. Accelerate developer builds by reusing CI results</h3>
<div class="paragraph">
<p>When multiple developers work on the same project, they don&#8217;t just need to build their own changes: whenever they pull from version control, they end up having to build each others' changes as well. If the pulled changes are sufficiently independent, the developer can safely reuse outputs already generated on CI. Say, you&#8217;re working on module "A", and you pull in some changes to module "B" (which does not depend on your module). If those changes were already built in CI, you can download the task outputs for module "B" from the cache instead of generating them locally.</p>
</div>
<div class="paragraph">
<p>The changes don&#8217;t need to be completely independent, either; we&#8217;ll take a look at the strategies to reuse results when dependencies are involved in the section about the <a href="#normalization">different forms of normalization</a>.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>TODO:</strong> Mention moving a Git tag to the latest published commit can help reduce problems with developers pulling too fresh changes.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="combine_ci_results_with_local_caching_on_developer_machines"><a class="anchor" href="#combine_ci_results_with_local_caching_on_developer_machines"></a>1.4. Combine CI results with local caching on developer machines</h3>
<div class="paragraph">
<p>Developers can utilize both a local and a remote cache. While pulling results from a CI-filled remote cache helps to avoid work needed because of changes by other developers, the local cache can speed up switching branches and doing <code>git bisect</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="share_results_between_developers"><a class="anchor" href="#share_results_between_developers"></a>1.5. Share results between developers</h3>
<div class="paragraph">
<p>Using the local cache is a sort of one-to-one thing, while the HTTP cache typically has a one-to-many topology. Gradle also allows the use of distributed caches, for example with using the <a href="https://github.com/gradle/gradle-hazelcast-plugin/">Hazelcast cache backend</a>.</p>
</div>
<div class="paragraph">
<p>It is also possible to allow developers to upload their results to a shared cache, thus making them available for everyone else, even before CI had a chance to build them.</p>
</div>
<div class="paragraph">
<p>While sharing results from developer machines seems like a good idea at first sight, it might not always be what you are looking for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The environment on developer machines is usually not as strictly controlled as it is on CI. Gradle tries to track every relevant bit of information that can influence a task&#8217;s output, but if there are tasks that are incorrectly defined, developers can pollite the cache with corrupted results.</p>
</li>
<li>
<p>Gradle is in general sage to be used with incremental builds. However, we recommend only uploading to a shared cache from <code>clean</code> builds.</p>
</li>
<li>
<p>Developers can make changes to task outputs while the task is running even unintentionally, or even unknowingly, like continuing making changes in their IDEs while the build is running. Currently Gradle has no good way to defend against these changes, and will simply cache whatever is in the output directory once the task is finished. This again can lead to corrupted results being uploaded to the shared cache.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="important_concepts"><a class="anchor" href="#important_concepts"></a>2. Important concepts</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="repeatable_task_outcomes"><a class="anchor" href="#repeatable_task_outcomes"></a>2.1. Repeatable task outcomes</h3>

</div>
<div class="sect2">
<h3 id="stable_task_inputs"><a class="anchor" href="#stable_task_inputs"></a>2.2. Stable task inputs</h3>

</div>
<div class="sect2">
<h3 id="normalization"><a class="anchor" href="#normalization"></a>2.3. Better reuse via input normalization</h3>
<div class="sect3">
<h4 id="path_sensitivity_and_relocatability"><a class="anchor" href="#path_sensitivity_and_relocatability"></a>2.3.1. Path sensitivity and relocatability</h4>

</div>
<div class="sect3">
<h4 id="compile_avoidance"><a class="anchor" href="#compile_avoidance"></a>2.3.2. Compile avoidance</h4>

</div>
<div class="sect3">
<h4 id="runtime_classpath_normalization"><a class="anchor" href="#runtime_classpath_normalization"></a>2.3.3. Runtime classpath normalization</h4>
<div class="sect4">
<h5 id="filtering"><a class="anchor" href="#filtering"></a>Filtering</h5>

</div>
</div>
</div>
<div class="sect2">
<h3 id="the_case_against_overlapping_outputs"><a class="anchor" href="#the_case_against_overlapping_outputs"></a>2.4. The case against overlapping outputs</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="debugging_and_diagnosing_cache_misses"><a class="anchor" href="#debugging_and_diagnosing_cache_misses"></a>3. Debugging and diagnosing cache misses</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For using task output caching efficiently it is essential to keep the balance between specifying all the inputs to your
tasks while not over-specifying them. If you don&#8217;t specify enough of your inputs then your build will be incorrect and you
will share outputs between tasks that should have had a different output. If you specify unnecessary inputs to your tasks,
 you will have cache misses while you could have reused earlier outputs.
 For Gradle&#8217;s built-in tasks we prefer to err on the side of correctness and we suggest that you do the same.</p>
</div>
<div class="paragraph">
<p>This chapter is about finding out why a cache miss was happening. If you have a cache hit which you didn&#8217;t expect we
suggest to declare whatever change you expected to trigger the cache miss as an input to the task.</p>
</div>
<div class="sect2">
<h3 id="how_to_find_problems_with_task_output_caching"><a class="anchor" href="#how_to_find_problems_with_task_output_caching"></a>3.1. How to find problems with task output caching</h3>
<div class="paragraph">
<p>In order to find existing problems with your usage of task output caching you can do a variety of things.</p>
</div>
<div class="paragraph">
<p>For example you can run a build with the same commit and check that this build is fully cached.
You probably should make sure that the project and the home directory changes between these builds to detect relocatability problems.</p>
</div>
<div class="paragraph">
<p>We had good experiences with recording execution times of our builds, generate graphs of those and then look at the results.
You then can look for certain patterns, like a rebuilding everything even though you expected compilation to be cached.</p>
</div>
<div class="paragraph">
<p>You can also make certain changes to your code base manually or automatically and check that the expected set of tasks is cached.</p>
</div>
<div class="paragraph">
<p>If these experiments point to a possible problem with your use of task output caching, you would need to go into diagnosing a cache miss as explained below.</p>
</div>
</div>
<div class="sect2">
<h3 id="helpful_data_for_diagnosing_a_cache_miss"><a class="anchor" href="#helpful_data_for_diagnosing_a_cache_miss"></a>3.2. Helpful data for diagnosing a cache miss</h3>
<div class="paragraph">
<p>A cache miss happens when Gradle calculates a build cache key for a task which is different from any of the build cache keys in the cache.
Only comparing the build cache key on its own does not give much information, so we need to look at some finer grained data to be able to diagnose the cache miss.
All the things influencing the build cache key can be found in the <a href="https://docs.gradle.org/4.0-rc-1/userguide/build_cache.html#sec:task_output_caching_details">userguide</a>.</p>
</div>
<div class="paragraph">
<p>Basically, we can compare the following data, listed from coarse grained to fine grained:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Build cache keys</p>
</li>
<li>
<p>Task and Task action implementation inputs</p>
</li>
<li>
<p>classloader hash</p>
</li>
<li>
<p>class name</p>
</li>
<li>
<p>Individual task property input hashes</p>
</li>
<li>
<p>Hashes of files which are part of task input properties</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Currently, the build cache key for the task is logged at the info level,
while information down to the individual input property level is available in the info log:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Appending taskClass to build cache key: org.gradle.api.tasks.compile.JavaCompile_Decorated
Appending classLoaderHash to build cache key: da6eca52100422099189290bf68f200a
Appending actionType to build cache key: org.gradle.api.internal.project.taskfactory.AbstractOutputPropertyAnnotationHandler$2$1
Appending actionClassLoaderHash to build cache key: 2cdf3f9202925b5befa161030ab43724
Appending actionType to build cache key: org.gradle.api.internal.project.taskfactory.TaskClassValidator
.
.
.
Appending inputPropertyHash for 'classpath' to build cache key: 2b6ab53aa11d4a7d4a1f95a8f78f4d7c
Appending inputPropertyHash for 'effectiveAnnotationProcessorPath' to build cache key: d41d8cd98f00b204e9800998ecf8427e
Appending inputPropertyHash for 'options.sourcepath' to build cache key: d41d8cd98f00b204e9800998ecf8427e
Appending inputPropertyHash for 'source' to build cache key: f6ba49b2466f0090272c43ac5f54ec1d
Appending outputPropertyName to build cache key: destinationDir
Build cache key for task ':compileJava' is 2b220117efa6710f7ab191a0bbe48c00</pre>
</div>
</div>
<div class="paragraph">
<p>If you want to go into the details of finding out e.g. which classes and jar files constitute the <code>classpath</code> for the <code>compileJava</code>
task you need to resort to comparing those files on disk yourself.</p>
</div>
<div class="paragraph">
<p>Luckily, you do not have to capture this data yourself - the build scan plugin already takes care of this for you.
This means that Gradle Enterprise already has the necessary data to diagnose the cache miss when using the build scan plugin.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/task-inputs-comparison.png" alt="task inputs comparison">
</div>
</div>
<div class="paragraph">
<p>Note that it is also possible that task output caching for a cacheable task was disabled.
When this happens the reason why caching was disabled for the task is reported on the info log level and in the build scan.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/caching-disabled.png" alt="caching disabled">
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>TODO:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Add current GE screenshot showing some differences</p>
</li>
</ul>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="diagnosing_the_reasons_for_a_cache_miss"><a class="anchor" href="#diagnosing_the_reasons_for_a_cache_miss"></a>3.3. Diagnosing the reasons for a cache miss</h3>
<div class="paragraph">
<p>Having the data from the last section at hand, you should be able to diagnose why the outputs of a certain task were not found in the build cache.
Since you were expecting more tasks to be cached, you should be able to pinpoint a build which would have produced the artifact under question.</p>
</div>
<div class="paragraph">
<p>Before diving into how to find out why one task has not been loaded from the cache we should first look into which task caused the cache misses.
There is a cascade effect causing dependent tasks to be executed if one of the tasks earlier in the build is not loaded from the cache and has different outputs.
Therefore, you should therefore at the first cacheable task which was executed and continue investigating there.
This can be done from the timeline view in a build scan.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/first-non-cached-task.png" alt="first non cached task">
</div>
</div>
<div class="paragraph">
<p>At first, you should check if the implementation of the task changed. This would mean checking the class names and classloader hashes
for the task class itself and for each of its action. If there is a change, this means that the build script, <code>buildSrc</code> or the Gradle version has changed.</p>
</div>
<div class="paragraph">
<p>If the implementation is the same, then you need to start comparing inputs between the two builds.
There should be at least one different input hash. If it is a simple value property, then the configuration of the task changed.
This can happen for example by</p>
</div>
<div class="ulist">
<ul>
<li>
<p>changing the build script,</p>
</li>
<li>
<p>conditionally configuring the task differently for CI or the developer builds,</p>
</li>
<li>
<p>depending on a system property or an environment variable for the task configuration,</p>
</li>
<li>
<p>or having an absolute path is part of the input.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the changed property is a file property, then the reasons can be the same as for the change of a value property.
Most probably though a file on the filesystem changed in a way that Gradle detects a difference for this input.
The most common case will be that the source code was changed by a check in.
It is also possible that a file generated by Gradle changed, e.g. since it includes a timestamp.
Note that the Java version can also influence the output of the Java compiler.
If you did not expect the file to be an input to the task, then it is possible that you should alter the configuration of the task to not include it.
For example, having your integration test configuration including all the unit test classes as a dependency has the effect that all integration tests
are re-executed when a unit test changes.
Another option is that the task tracks absolute paths instead of relative paths and the location of the project directory changed on disk.</p>
</div>
</div>
<div class="sect2">
<h3 id="example"><a class="anchor" href="#example"></a>3.4. Example</h3>
<div class="paragraph">
<p>We will walk you through the process of diagnosing a cache miss.
Let&#8217;s say we have build <code>A</code> and build <code>B</code> and we expected all the test tasks for a sub-project <code>sub1</code> to be cached in build <code>B</code> since only a unit test for another sub-project <code>sub2</code> changed.
Actually, all the tests for the sub-project have been executed.
Since we have the cascading effect when we have cache misses, we need to find the task which caused the caching chain to fail.
This can easily be done by filtering for all cacheable tasks which have been executed and then select the first one.
In our case, it turns out that the tests for the sub-project <code>internal-testing</code> were executed even though there was no code change to this project.
We start the input property comparison in Gradle Enterprise and see that the property <code>classpath</code> changed. This means that some file on the runtime classpath actually did change.
Looking deeper into this, we actually see that the inputs for the task <code>processResources</code> changed in that project, too.
Finally, we find this in our build file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task currentVersionInfo() {
    doLast {
        <span class="keyword">def</span> properties = <span class="keyword">new</span> <span class="predefined-type">Properties</span>()
        properties.latestMilestone = version
        properties.store(<span class="keyword">new</span> <span class="predefined-type">File</span>(generatedResourcesDir, <span class="string"><span class="delimiter">&quot;</span><span class="content">currentVersion.properties</span><span class="delimiter">&quot;</span></span>))
    }
}

sourceSets.main.output.dir generatedResourcesDir, <span class="key">builtBy</span>: currentVersionInfo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since properties files stored by Java&#8217;s <code>Properties.store</code> method contain a timestamp, this will cause a change to the runtime classpath every time the build runs.
Note that the compile classpath is not affected since compile avoidance ignores non-class files on the compile classpath.
In order to solve this problem have a look at <a href="#volatile_data">Volatile data in build artifacts</a>.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>TODO:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Add GE screenshots</p>
</li>
</ul>
</div>
</blockquote>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="common_problems_and_their_solutions"><a class="anchor" href="#common_problems_and_their_solutions"></a>4. Common problems and their solutions</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="system_file_encoding"><a class="anchor" href="#system_file_encoding"></a>4.1. System file encoding</h3>
<div class="paragraph">
<p>Most Java tools use the system file encoding when no specific encoding is specified.
This means that running the same build on machines with different file encoding can yield different outputs.
Gradle currently does only track that no file encoding has been specified on a task basis - but it does not track the system encoding of the JVM it is using.
This can cause incorrect builds. You should always set the file system encoding to avoid these kind of problems.</p>
</div>
</div>
<div class="sect2">
<h3 id="environment_variable_tracking"><a class="anchor" href="#environment_variable_tracking"></a>4.2. Environment variable tracking</h3>
<div class="paragraph">
<p>Gradle does currently not track environment variables for tasks.
For example for the <code>Test</code> tasks it is completely possible that the outcome depends on a few environment variables.
To ensure that only the right artifacts are re-used between builds you need to add environment variables as an input to the tasks depending on them.</p>
</div>
<div class="paragraph">
<p>Absolute paths are often passed as environment variables, too. You need to pay attention what you add as an input to the task in this case. If you add the absolute path then it will be very hard to re-use task outputs between different machines.
You would need to ensure that the absolute path is the same between machines. Most times it makes sense to track the file or the contents of the directory the absolute path points to.
If the absolute path represents a tool being used it probably makes sense to track the tool version as an input instead.</p>
</div>
<div class="paragraph">
<p>If you are adding conditional logic whether you are building on CI or on a developer machine make sure that this does not break loading task outputs on developer machines from CI.
For example, the following setup would break caching of <code>Test</code> tasks, since Gradle always would detect the difference in custom task actions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">if</span> (<span class="predefined-type">System</span>.getenv().containsKey(<span class="string"><span class="delimiter">&quot;</span><span class="content">CI</span><span class="delimiter">&quot;</span></span>) {
    test.doFirst {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Running test on CI</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should always add the action unconditionally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">test.doFirst {
    <span class="keyword">if</span> (<span class="predefined-type">System</span>.getenv().containsKey(<span class="string"><span class="delimiter">&quot;</span><span class="content">CI</span><span class="delimiter">&quot;</span></span>) {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Running test on CI</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This way, the task has the same custom action on CI and on developer builds and its outputs can be re-used if the remaining inputs are the same.</p>
</div>
</div>
<div class="sect2">
<h3 id="line_endings"><a class="anchor" href="#line_endings"></a>4.3. Line endings</h3>
<div class="paragraph">
<p>If you are building on different operating systems be aware that some version control systems convert line endings on check-out.
For example, Git on Windows uses <code>autocrlf=true</code> by default which converts all line endings to <code>\r\n</code>.
As a consequence, compilation outputs can&#8217;t be re-used on Windows since the input sources are different.
You should make sure to configure <code>autocrlf=false</code> across your build machines to ensure optimal build cache usage.</p>
</div>
</div>
<div class="sect2">
<h3 id="symbolic_links"><a class="anchor" href="#symbolic_links"></a>4.4. Symbolic links</h3>
<div class="paragraph">
<p>Gradle does not store the symbolic link in the build cache but the actual file contents of the destination of the link.
As a consequence you might have a hard time when trying to re-use outputs which heavily use symbolic links.
There currently is no workaround for this behavior.</p>
</div>
</div>
<div class="sect2">
<h3 id="java_version_tracking"><a class="anchor" href="#java_version_tracking"></a>4.5. Java version tracking</h3>
<div class="paragraph">
<p>Gradle does track the major version of Java as an input for compilation and test execution.
Currently, it does neither track the vendor nor the minor version.
Still, the vendor and the minor version may influence the bytecode produced by compilation.</p>
</div>
<div class="paragraph">
<p>If you use different JVM vendors for compiling or running Java we strongly suggest that you add the vendor as an input to the corresponding tasks.
This can be achieved by using the <a href="https://docs.gradle.org/4.0-rc-1/userguide/more_about_tasks.html#sec:task_input_output_runtime_api">runtime API</a> as shown in the following snippet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.withType(AbstractCompile) {
    inputs.property(<span class="string"><span class="delimiter">&quot;</span><span class="content">java.vendor</span><span class="delimiter">&quot;</span></span>) {
        <span class="predefined-type">System</span>.getProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">java.vendor</span><span class="delimiter">&quot;</span></span>)
    }
}

tasks.withType(Test) {
    inputs.property(<span class="string"><span class="delimiter">&quot;</span><span class="content">java.vendor</span><span class="delimiter">&quot;</span></span>) {
        <span class="predefined-type">System</span>.getProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">java.vendor</span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With respect to tracking the Java minor version there are different competing aspects: support pulling results for developers and having "perfect" results on CI. There are basically two situations when you may want to track the minor version number of Java: compilation and for runtime.</p>
</div>
<div class="paragraph">
<p>For compilation we saw sometimes differences in the produced bytecode for different minor version numbers. The bytecode should still expose the same runtime behavior.
Note that <a href="https://docs.gradle.org/4.0-rc-1/userguide/java_plugin.html#sec:java_compile_avoidance">Java compile avoidance</a> will treat this bytecode the same since it extracts the ABI.</p>
</div>
<div class="paragraph">
<p>Treating the minor number always as an input would it make very hard for developers to pull from the build cache. We saw that even in bigger companies different developers on the same team were using different Java minor versions. If you are able to control the environment in a way that everybody in your team and on CI is using exactly the same Java minor version then we suggest that you add the minor version as an input.</p>
</div>
<div class="paragraph">
<p>Note that even without tracking the Java minor version you may have cache misses for developers due to some locally compiled class files which constitute an input to test execution.
If these outputs made it into the local build cache on this developers machine even a clean will not solve this situation.
Therefore, the choice for tracking the Java minor version is between sometimes or never re-using outputs between for test execution between different Java minor versions.</p>
</div>
<div class="paragraph">
<p>Note that the compiler infrastructure provided by the JVM used to run Gradle is also used by the Groovy compiler.
Therefore, you can expect differences in the bytecode of compiled Groovy classes for the same reasons as above and the same suggestions apply.</p>
</div>
</div>
<div class="sect2">
<h3 id="avoid_changing_inputs_external_to_your_build"><a class="anchor" href="#avoid_changing_inputs_external_to_your_build"></a>4.6. Avoid changing inputs external to your build</h3>
<div class="paragraph">
<p>If your build is dependent on external dependencies like binary artifacts or dynamic data from a web page you need to make sure that these inputs are consistent throughout your infrastructure.
When there are some variations between machines then there will be no cache hits.</p>
</div>
<div class="paragraph">
<p>Never re-release a non-changing binary dependency with the same version number but different contents: if this happens with a plugin dependency, you will never be able to explain why you don’t see cache reuse between machines (it’s because they have different versions of that artifact).</p>
</div>
<div class="paragraph">
<p>For changing binary dependencies you would need to pay attention whether the same dependency is used throughout your build pipeline.
You may want to look into the <a href="https://github.com/nebula-plugins/gradle-dependency-lock-plugin">dependency lock plugin</a> or switch to using <a href="https://docs.gradle.org/4.0-rc-1/userguide/composite_builds.html">composite builds</a> instead.</p>
</div>
<div class="paragraph">
<p>The same is true for depending on volatile external resources, for example a list of released versions.
One way of locking the changes would be to check in the volatile resource whenever it changes so that the builds only depend on the state in source control and not on the volatile resource itself.</p>
</div>
</div>
<div class="sect2">
<h3 id="suggestions_for_authoring_your_build"><a class="anchor" href="#suggestions_for_authoring_your_build"></a>4.7. Suggestions for authoring your build</h3>
<div class="sect3">
<h4 id="review_usages_of_code_dofirst_code"><a class="anchor" href="#review_usages_of_code_dofirst_code"></a>4.7.1. Review usages of <code>doFirst</code></h4>
<div class="paragraph">
<p>Using <code>doFirst</code> from a build script on a cacheable tasks ties you to build script changes since the implementation of the closure comes from the build script.
If possible, you should use a separate tasks instead.</p>
</div>
<div class="paragraph">
<p>Modifying inputs or output properties via the runtime API in <code>doFirst</code> is discouraged since these changes will not be detected for up-to-date checks and the build cache.
Even worse, when the task does not execute then the configuration of the task is actually different from when it executes.
Instead of using <code>doFirst</code> for modifying the inputs consider using a separate tasks to configure the task under question - a so called configure task.
E.g., instead of doing</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">jar {
    doFirst {
        jar.manifest.mainAttributes(<span class="string"><span class="delimiter">'</span><span class="content">Class-Path</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>project(<span class="string"><span class="delimiter">'</span><span class="content">:core</span><span class="delimiter">'</span></span>).jar.archivePath.name<span class="inline-delimiter">}</span></span><span class="content"> </span><span class="inline"><span class="inline-delimiter">${</span>project(<span class="string"><span class="delimiter">'</span><span class="content">:baseServices</span><span class="delimiter">'</span></span>).jar.archivePath.name<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>do</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task configureJar {
    doLast {
        jar.manifest.mainAttributes(<span class="string"><span class="delimiter">'</span><span class="content">Class-Path</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>project(<span class="string"><span class="delimiter">'</span><span class="content">:core</span><span class="delimiter">'</span></span>).jar.archivePath.name<span class="inline-delimiter">}</span></span><span class="content"> </span><span class="inline"><span class="inline-delimiter">${</span>project(<span class="string"><span class="delimiter">'</span><span class="content">:baseServices</span><span class="delimiter">'</span></span>).jar.archivePath.name<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
    }
}

jar.dependsOn(configureJar)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="logic_based_on_task_outcome"><a class="anchor" href="#logic_based_on_task_outcome"></a>4.7.2. Build logic based on the outcome of a task</h4>
<div class="paragraph">
<p>Do not base build logic on whether a task has been <em>executed</em>.
In particular you should not assume that the output of a task can only change if it did actually execute.
The outputs could have been loaded from the build cache, too.
In general, you should work together Gradle&#8217;s up-to-date checks since this will ensure that task output caching has the same view of the task.
Using <code>outputs.upToDateWhen</code> is discouraged and should be better modelled by adding the right inputs to the task.</p>
</div>
</div>
<div class="sect3">
<h4 id="overlapping_outputs"><a class="anchor" href="#overlapping_outputs"></a>4.7.3. Overlapping outputs</h4>
<div class="paragraph">
<p>If two tasks write to the same output directory or output file they cannot be cached and task output caching will be automatically disabled for the task.
Gradle&#8217;s built-in tasks are configured in a way that there will not be any overlapping outputs.
When you add new tasks to your build or re-configure built-in tasks make sure you do not create overlapping outputs for cacheable tasks.
If you must you can add a <code>Sync</code> task which then would sync the merged outputs into the target directory while the original tasks remain cacheable.</p>
</div>
<div class="paragraph">
<p>Gradle Enterprise will show tasks where caching was disabled for overlapping outputs in the timeline.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/overlapping-outputs-timeline.png" alt="overlapping outputs timeline">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="volatile_data"><a class="anchor" href="#volatile_data"></a>4.8. Volatile data in build artifacts</h3>
<div class="paragraph">
<p>If you include timestamps or other volatile data like Git commit ids in task inputs or outputs then it will be difficult for Gradle to re-use these between builds.
We will go through different instances of volatile data and how to work around using the build cache anyway.</p>
</div>
<div class="sect3">
<h4 id="volatile_inputs"><a class="anchor" href="#volatile_inputs"></a>4.8.1. Volatile inputs</h4>
<div class="paragraph">
<p>If you use a volatile input like a timestamp as an input property for a task, then there is nothing Gradle can do to make the task cacheable.
You should really think hard if the volatile data is really essential to the output or if it is only there for e.g. auditing purposes.</p>
</div>
<div class="paragraph">
<p>If the volatile input is essential to the output then you can try to make the task using the input cheaper to execute.
You can do this by splitting the task into two tasks - the first task doing the expensive work which is cacheable and the second task adding the volatile data to the output.
In this way the output stays the same and the build cache can be used to avoid doing the expensive work.
For example for building a jar file the expensive part - Java compilation - is already a different task while the jar task itself, which is not cacheable, is cheap.</p>
</div>
<div class="paragraph">
<p>If it is not an essential part of the output, then you should not declare it as an input.
As long as the volatile input does not influence the output then there is nothing else to do.
Most times though, the input will be part of the output.</p>
</div>
</div>
<div class="sect3">
<h4 id="volatile_outputs"><a class="anchor" href="#volatile_outputs"></a>4.8.2. Volatile outputs</h4>
<div class="paragraph">
<p>Having tasks which generate different outputs for the same inputs can pose a challenge for the effective use of task output caching.
If the task output containing the volatile data is not used by any other task then the effect is very limited.
It basically means that pulling from the cache might produce a different result than executing the same task locally.
If the only difference between the outputs is a timestamp then you can either accept the effect of the build cache or decide that the task is not cacheable after all.</p>
</div>
<div class="paragraph">
<p>The story is different if an other task depend on the volatile outputs of a task.
For example, re-creating a jar file from the files with the same contents but different modification times yields a different jar file.
Any other task depending on this jar file as an input file could not be loaded from the cache when the jar file is rebuilt locally.
This can lead to hard to diagnose cache misses when the consuming build is not a clean build.
For example when doing incremental builds it is possible that the artifact on disk which is considered up-to-date and
the artifact in the build cache are different even though they are essentially the same.
A task depending on this task output would then not be able to load outputs from the build cache since the inputs are not exactly the same.</p>
</div>
<div class="sect4">
<h5 id="input_normalization"><a class="anchor" href="#input_normalization"></a>Input normalization</h5>
<div class="paragraph">
<p>This is where <a href="https://docs.gradle.org/4.0-rc-1/userguide/more_about_tasks.html#sec:configure_input_normalization">input normalization</a> comes into play.
Input normalization is used by Gradle to determine if two task inputs are essentially the same.
Gradle compares normalized inputs when doing up-to-date checks and when determining the build cache key.
For a non-specialized input property Gradle doesn&#8217;t do much - it looks at the content of the property or the files and compares those.</p>
</div>
<div class="paragraph">
<p>As soon as Gradle understands that the input is a runtime classpath it switches to a smarter behavior since the concept of a classpath is known to Gradle.
For example, for a runtime classpath Gradle inspects the contents of jar files and ignores the timestamps of the entries of the jar file.
This means that a rebuilt jar file would be considered the same runtime classpath input.
The details what level of understanding Gradle uses for detecting changes to classpath see the <a href="https://docs.gradle.org/4.0-rc-1/userguide/more_about_tasks.html#sec:task_input_using_classpath_annotations">userguide</a>.</p>
</div>
<div class="paragraph">
<p>For a runtime classpath it is possible to provide better insights to Gradle which files are essential to the input by <a href="https://docs.gradle.org/4.0-rc-1/userguide/more_about_tasks.html#sec:configure_input_normalization">configuring input normalization</a>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say you want to add a file <code>build-info.properties</code> to all your produced jar files which contains volatile information about the build, e.g. the timestamp when the build started or some ID to identify the CI job that published the artifact.
This file is only for auditing purposes, and has no effect on the outcome of running tests.
Nonetheless, this file is part of the runtime classpath for the <code>test</code> task and changes on every build invocation.
In order to benefit from task output caching again you can add the following configuration to your project.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">normalization {
    runtimeClasspath {
        ignore <span class="string"><span class="delimiter">&quot;</span><span class="content">build-info.properties</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The effect of this configuration would be that changes to <code>build-info.properties</code> would be ignored for up-to-date checks and build cache key calculations.
Note that this will not change the runtime behavior of the <code>test</code> task - i.e. any test is still able to load <code>build-info.properties</code> and the runtime classpath is still the same as before.</p>
</div>
<div class="paragraph">
<p>If input normalization doesn&#8217;t provide the necessary features then you can also try to make the task reproduce the output byte per byte on each invocation.</p>
</div>
</div>
<div class="sect4">
<h5 id="reproducible_outputs"><a class="anchor" href="#reproducible_outputs"></a>Reproducible outputs</h5>
<div class="paragraph">
<p>While input normalization provides a way to describe what is essential for the consumer of an artifact, reproducible outputs aim to solve the same problem on the producer side.
If possible, using input normalization should be the preferred way to address problems with volatile outputs.
Note that can be challenging to have tasks reproduce exactly the same byte per byte output for the same inputs.</p>
</div>
<div class="paragraph">
<p>For tar and zip files Gradle can be configured to create <a href="https://docs.gradle.org/4.0-rc-1/userguide/working_with_files#sec:reproducible_archives">reproducible archives</a>.
This is done by configuring e.g. the <code>Zip</code> task via the following snippet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task createZip(<span class="key">type</span>: Zip) {
    preserveFileTimestamps = <span class="predefined-constant">false</span>
    reproducibleFileOrder = <span class="predefined-constant">true</span>
...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another way to make the outputs reproducible is to activate caching for a task with volatile outputs.
If you can make sure that the same build cache is used for all builds then the task will always have the same outputs for the same inputs by design of the build cache.
Going down this road can lead to different problems with cache misses for incremental builds as described above.
Moreover, race conditions between different builds trying to store the same outputs in the build cache in parallel can lead to hard to diagnose cache misses.
If possible, you should avoid going down that route.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="limit_the_effect_of_volatile_data"><a class="anchor" href="#limit_the_effect_of_volatile_data"></a>4.8.3. Limit the effect of volatile data</h4>
<div class="paragraph">
<p>If none of the described solutions for dealing with volatile data work for you, you should still be able to limit the effect of volatile data on effective use of the build cache.
This can be done by adding the volatile data later to the outputs as described in <a id="volatile_inputs"></a>.
Another option would be to move the volatile data so it affects less tasks.
For example moving the dependency from the <code>compile</code> to the <code>runtime</code> configuration may already have quite an impact.</p>
</div>
<div class="paragraph">
<p>Sometimes it is also possible to build two artifacts, one containing the volatile data and another one containing a constant representation of the volatile data.
The non-volatile output would be used e.g. for testing while the volatile one would be published to an external repository.
This is in conflict with the Continuous Delivery "build artifacts once" principle but can sometimes be the only option.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="custom_and_third_party_tasks"><a class="anchor" href="#custom_and_third_party_tasks"></a>4.9. Custom and third party tasks</h3>
<div class="paragraph">
<p>If your build contains custom or third party tasks, you should take special care that these don&#8217;t influence the effectiveness of the build cache.
Special care should be taken for code generation tasks which may produce <a href="#volatile_outputs">Volatile outputs</a>.
This can happen if the code generator includes e.g. a timestamp in the generated files or depends on the order of the input files.
Other pitfalls can be the use of `HashMap`s or other data structures without order guarantees in the tasks code.</p>
</div>
<div class="paragraph">
<p>Note that some third party tasks can even influence cacheability of Gradle&#8217;s built-in tasks.
This can happen if they add inputs like absolute paths or volatile data to Gradle&#8217;s built-in tasks via the runtime API.
In the worst case this can lead to incorrect builds when the plugins try to depend on <a href="#logic_based_on_task_outcome">outcome of a task</a> and do not take <code>FROM-CACHE</code> into account.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="summary"><a class="anchor" href="#summary"></a>5. Summary</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>TBC</strong></p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-05-30 20:07:49 UTC
</div>
</div>
</body>
</html>