<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<title>Build Cache Practices</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
<link rel="stylesheet" href="https://guides.gradle.org/asciidoctor.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,400,700|Source+Code+Pro:500">
<link rel="apple-touch-icon" sizes="180x180" href="https://guides.gradle.org/icon/apple-touch-icon.png">
<link rel="icon" type="image/png" href="https://guides.gradle.org/icon/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="https://guides.gradle.org/icon/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="https://guides.gradle.org/icon/manifest.json">
<link rel="mask-icon" href="https://guides.gradle.org/icon/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="https://guides.gradle.org/icon/favicon.ico">
<meta name="apple-mobile-web-app-title" content="Build Cache Practices">
<meta name="application-name" content="Build Cache Practices">
<meta name="msapplication-config" content="https://guides.gradle.org/icon/browserconfig.xml">
<meta name="theme-color" content="#ffffff">
<script defer src="https://guides.gradle.org/js/set-time-to-complete-text.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i["GoogleAnalyticsObject"]=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,"script","https://www.google-analytics.com/analytics.js","ga");
  ga("create", "UA-4207603-1", "auto");
  ga("send", "pageview");
</script>
</head>
<body class="article toc2 toc-right">
<div id="header"><div style="padding-top: 10px;"><a href="https://guides.gradle.org"><img src="http://guides.gradle.org/gradle-guides.svg" alt=""></a></div><h1>Build Cache Practices</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#use_cases_for_the_build_cache">1. Use cases for the build cache</a>
<ul class="sectlevel2">
<li><a href="#speed_up_developer_builds_with_the_local_cache">1.1. Speed up developer builds with the local cache</a></li>
<li><a href="#share_results_between_ci_builds">1.2. Share results between CI builds</a></li>
<li><a href="#accelerate_developer_builds_by_reusing_ci_results">1.3. Accelerate developer builds by reusing CI results</a></li>
<li><a href="#combine_ci_results_with_local_caching_on_developer_machines">1.4. Combine CI results with local caching on developer machines</a></li>
<li><a href="#share_results_between_developers">1.5. Share results between developers</a></li>
</ul>
</li>
<li><a href="#build_cache_performance">2. Build cache performance</a>
<ul class="sectlevel2">
<li><a href="#fully_cached_builds">2.1. Fully cached builds</a></li>
<li><a href="#cache_impact_on_ci_builds">2.2. Cache impact on CI builds</a></li>
<li><a href="#measuring_developer_builds">2.3. Measuring developer builds</a></li>
</ul>
</li>
<li><a href="#important_concepts">3. Important concepts</a>
<ul class="sectlevel2">
<li><a href="#stable_task_inputs">3.1. Stable task inputs</a></li>
<li><a href="#concepts_repeatable_task_outputs">3.2. Repeatable task outputs</a></li>
<li><a href="#normalization">3.3. Better reuse via input normalization</a></li>
<li><a href="#concepts_overlapping_outputs">3.4. The case against overlapping outputs</a></li>
<li><a href="#reuse_of_task_outputs_with_the_same_inputs_but_different_task_paths">3.5. Reuse of task outputs with the same inputs, but different task paths</a></li>
<li><a href="#non_cacheable_tasks">3.6. Non-cacheable tasks</a></li>
</ul>
</li>
<li><a href="#debugging_and_diagnosing_cache_misses">4. Debugging and diagnosing cache misses</a>
<ul class="sectlevel2">
<li><a href="#how_to_find_problems_with_task_output_caching">4.1. How to find problems with task output caching</a></li>
<li><a href="#helpful_data_for_diagnosing_a_cache_miss">4.2. Helpful data for diagnosing a cache miss</a></li>
<li><a href="#diagnosing_cache_miss">4.3. Diagnosing the reasons for a cache miss</a></li>
<li><a href="#example">4.4. Example</a></li>
</ul>
</li>
<li><a href="#common-problems">5. Common problems and their solutions</a>
<ul class="sectlevel2">
<li><a href="#system_file_encoding">5.1. System file encoding</a></li>
<li><a href="#environment_variable_tracking">5.2. Environment variable tracking</a></li>
<li><a href="#line_endings">5.3. Line endings</a></li>
<li><a href="#symbolic_links">5.4. Symbolic links</a></li>
<li><a href="#java_version_tracking">5.5. Java version tracking</a></li>
<li><a href="#avoid_changing_inputs_external_to_your_build">5.6. Avoid changing inputs external to your build</a></li>
<li><a href="#suggestions_for_authoring_your_build">5.7. Suggestions for authoring your build</a></li>
<li><a href="#achieving_stable_task_inputs">5.8. Achieving stable task inputs</a></li>
<li><a href="#custom_and_third_party_tasks">5.9. Custom and third party tasks</a></li>
</ul>
</li>
<li><a href="#summary">6. Summary</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The best way to do work faster is to not do work that doesn’t need doing. Gradle has two main mechanisms to avoid work at the task level:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>incremental build</strong> avoids running a task if its inputs and outputs are equivalent to what they were during its previous execution,</p>
</li>
<li>
<p><strong>task output caching</strong> reuses task outputs produced with the same inputs anytime before, on any machine that is connected to the same build cache backend.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This guide covers the different use cases for Gradle’s build cache, from local-only development to caching task outputs across large teams. We will discuss ways to measure the advantages provided by the build cache, and methods to improve cache performance, or to diagnose and fix common problems. Let’s dive in!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="use_cases_for_the_build_cache"><a class="anchor" href="#use_cases_for_the_build_cache"></a>1. Use cases for the build cache</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gradle’s build cache is a versatile feature that can be used in different ways.</p>
</div>
<div class="sect2">
<h3 id="speed_up_developer_builds_with_the_local_cache"><a class="anchor" href="#speed_up_developer_builds_with_the_local_cache"></a>1.1. Speed up developer builds with the local cache</h3>
<div class="paragraph">
<p>Even when used by a single developer only, the build cache can be pretty useful. Gradle&#8217;s <em>incremental build</em> feature helps avoid work that is already done, but once you change the inputs of a task, it forgets any previous results. When you are switching branches back and forth, the local results get rebuilt over and over again, even if you are building something that has already been built before. The build cache remembers, though, and heavily reduces the need to rebuild things when they were already built locally. In general it&#8217;s very useful when you need to rebuild different commits, like when running <code>git bisect</code>.</p>
</div>
<div class="paragraph">
<p>The local cache can also be useful when working with a project that has multiple variants dimensions, like in the case of Android applications. Each variant has a number of tasks associated with it, and some of those task variants, despite having different names, can end up doing the same things. With the local cache enabled reuse between task variants will happen automatically when applicable.</p>
</div>
</div>
<div class="sect2">
<h3 id="share_results_between_ci_builds"><a class="anchor" href="#share_results_between_ci_builds"></a>1.2. Share results between CI builds</h3>
<div class="paragraph">
<p>The build cache can do more than going back-and-forth in time: it can also bridge physical distance between computers, allowing to reuse results generated on one machine to be reused by another. A usual first step when introducing the build cache within a team is to enable it for builds running as part of <em>continuous integration</em> only. Using a shared HTTP build cache backend (such as <a href="https://gradle.com/build-cache/">the one provided by Gradle Enterprise</a>) can significantly reduce the work CI agents need to do. This translates into faster feedback to developers, and less money spent on the CI infrastructure.</p>
</div>
<div class="paragraph">
<p>Using the build cache on CI first makes sense as the environment on CI agents is usually easier to control than developer machines.
It helps to point out possible issues with the build that hurt cacheability.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>TODO:</strong> Discus audit requirements.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="accelerate_developer_builds_by_reusing_ci_results"><a class="anchor" href="#accelerate_developer_builds_by_reusing_ci_results"></a>1.3. Accelerate developer builds by reusing CI results</h3>
<div class="paragraph">
<p>When multiple developers work on the same project, they don&#8217;t just need to build their own changes: whenever they pull from version control, they end up having to build each others' changes as well. If the pulled changes are sufficiently independent, the developer can safely reuse outputs already generated on CI. Say, you&#8217;re working on module "A", and you pull in some changes to module "B" (which does not depend on your module). If those changes were already built in CI, you can download the task outputs for module "B" from the cache instead of generating them locally.</p>
</div>
<div class="paragraph">
<p>The changes don&#8217;t need to be completely independent, either; we&#8217;ll take a look at the strategies to reuse results when dependencies are involved in the section about the <a href="#normalization">different forms of normalization</a>.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>TODO:</strong> Mention using a Git branch for latest published commit can help reduce problems with developers pulling too fresh changes.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="combine_ci_results_with_local_caching_on_developer_machines"><a class="anchor" href="#combine_ci_results_with_local_caching_on_developer_machines"></a>1.4. Combine CI results with local caching on developer machines</h3>
<div class="paragraph">
<p>Developers can utilize both a local and a remote cache. While pulling results from a CI-filled remote cache helps to avoid work needed because of changes by other developers, the local cache can speed up switching branches and doing <code>git bisect</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="share_results_between_developers"><a class="anchor" href="#share_results_between_developers"></a>1.5. Share results between developers</h3>
<div class="paragraph">
<p>Using the local cache is a sort of one-to-one thing, while the HTTP cache typically has a one-to-many topology. Gradle also allows the use of distributed caches, for example with using the <a href="https://github.com/gradle/gradle-hazelcast-plugin/">Hazelcast cache backend</a>.</p>
</div>
<div class="paragraph">
<p>It is also possible to allow developers to upload their results to a shared cache, thus making them available for everyone else, even before CI had a chance to build them.</p>
</div>
<div class="paragraph">
<p>While sharing results from developer machines seems like a good idea at first sight, it might not always be what you are looking for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The environment on developer machines is usually not as strictly controlled as it is on CI. Gradle tries to track every relevant bit of information that can influence a task&#8217;s output, but if there are tasks that are incorrectly defined, developers can pollute the cache with corrupted results.</p>
</li>
<li>
<p>Gradle is in general safe to be used with incremental builds. However, we recommend only uploading to a shared cache from <code>clean</code> builds.</p>
</li>
<li>
<p>Developers can make changes to task outputs while the task is running even unintentionally, or even unknowingly, like continuing making changes in their IDEs while the build is running. Currently, Gradle has no good way to defend against these changes, and will simply cache whatever is in the output directory once the task is finished. This again can lead to corrupted results being uploaded to the shared cache.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="build_cache_performance"><a class="anchor" href="#build_cache_performance"></a>2. Build cache performance</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The sole reason to use any build cache is to make builds faster. But how much faster can you go when using the cache? Measuring the impact is both important and complicated, as cache performance is determined by many factors. Initial measurements of the cache&#8217;s impact can validate the extra effort (work, infrastructure) that was required to start using the cache. These measurements can later serve as baselines for future improvements, and to watch for signs of regressions.</p>
</div>
<div class="sect2">
<h3 id="fully_cached_builds"><a class="anchor" href="#fully_cached_builds"></a>2.1. Fully cached builds</h3>
<div class="paragraph">
<p>The most straightforward way to get a feel for what the cache can do for you is to measure the difference between a non-cached build and a <em>fully cached</em> build. This will give you the theoretical limit of how fast builds with the cache can get, if everything you&#8217;re trying to build has already been built. The easiest way to measure this is using the local cache:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Clean the cache directory to avoid any hits from previous builds (<code>rm -rf $GRADLE_HOME/caches/build-cache-*</code>)</p>
</li>
<li>
<p>Run the build (e.g. <code>./gradlew --build-cache clean assemble</code>), so that all the results from cacheable tasks get stored in the cache.</p>
</li>
<li>
<p>Run the build again (e.g. <code>./gradlew --build-cache clean assemble</code>); depending on your build, this time you should see many of the tasks being cached.</p>
</li>
<li>
<p>Compare the execution time for the two builds</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You might have encountered a few cached tasks even in the first of the two builds, where no previously cached results should be available. This can happen if you have tasks in your build that are configured to produce the same results from the same inputs; in such a case once one of these tasks has finished, Gradle will simply reuse its output for the rest of the tasks.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Normally, your <em>fully cached</em> build should be significantly faster than the <code>clean</code> build: this is the theoretical limit of how much time using the build cache can save on your particular build when running the tasks that you were running. We&#8217;ll be covering several common causes for why your build might not produce amazing numbers here for the first try.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>TODO:</strong> Link to where we discuss problems.</p>
</div>
</blockquote>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>TODO:</strong> Mention that build scans can provide more info about task execution stats.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>In everyday situations fully cached builds are rare, as the purpose of running a build is to process some new changes. The structure of the software being built (how many modules are there, how independent are its parts etc.), and the nature of the changes themselves ("big refactor in the core of the system" vs. "small change to a unit test" etc.) strongly influence the caching performance. As developers tend to submit different kinds of changes over time, caching performance is expected to vary with each change. As with any cache, the impact should thus be measured over time.</p>
</div>
<div class="paragraph">
<p>In a setup where a team uses a shared cache backend, there are two locations worth measuring cache impact at: on CI and on developer machines.</p>
</div>
</div>
<div class="sect2">
<h3 id="cache_impact_on_ci_builds"><a class="anchor" href="#cache_impact_on_ci_builds"></a>2.2. Cache impact on CI builds</h3>
<div class="paragraph">
<p>The best way to learn about the impact of caching on CI is to set up the same builds with the cache enabled and disabled, and compare the results over time. If you have a single Gradle build step that you want to enable caching for, it&#8217;s easy to compare the results using your CI system&#8217;s built-in statistical tools.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>TODO:</strong> Graph of Gradle&#8217;s cache performance for sanity check between cached and non-cached</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Measuring complex pipelines requires some more work, and some external tool to collect and process measurements. It&#8217;s important to distinguish parts of the pipeline that caching has no effect on, for example the time builds spend waiting in the CI system&#8217;s queue, or time taken by checking out source code from version control.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>TODO:</strong> Do we know of tools for TeamCity or Jenkins that make the collection of such data easier?</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Typically, CI builds above a certain size include parallel sections to utilize multiple agents. With parallel pipelines you can measure the wall-clock time it takes for a set of changes to go from having been pushed to version control to being built, verified and deployed. The build cache&#8217;s effect in this case can be measured in the reduction of the time developers have to wait for feedback from CI.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>TODO:</strong> Graph of Gradle&#8217;s cache performance - from <a href="https://docs.google.com/spreadsheets/d/1dCYVAL9Qw2_ZpAdXfZAABEpLm-Q8PzD4G1etUq430zY/edit#gid=1079649909" class="bare">https://docs.google.com/spreadsheets/d/1dCYVAL9Qw2_ZpAdXfZAABEpLm-Q8PzD4G1etUq430zY/edit#gid=1079649909</a></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>You can also measure the cumulative time it took to build a changeset, which will give you a sense of the amount of work the CI infrastructure has to excert. The cache&#8217;s effect here is less money spent on CI infrastructure, as you don&#8217;t need as many CI agents to maintain the same number of changes built.</p>
</div>
</div>
<div class="sect2">
<h3 id="measuring_developer_builds"><a class="anchor" href="#measuring_developer_builds"></a>2.3. Measuring developer builds</h3>
<div class="paragraph">
<p>Gradle&#8217;s build cache can be very useful in reducing CI infrastructure cost and feedback time, but it usually has the biggest impact when developers can reuse cached results in their local builds. This is also the hardest to quantize for a number of reasons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>developers run different builds</p>
</li>
<li>
<p>developers can have different hardware, or have different settings</p>
</li>
<li>
<p>developers run all kinds of other things on their machines that can slow them down</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="important_concepts"><a class="anchor" href="#important_concepts"></a>3. Important concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As we said before, how much of your build gets loaded from cache depends on many factors. In this section we&#8217;ll review some of the tools that are essential for well-cached builds.</p>
</div>
<div class="sect2">
<h3 id="stable_task_inputs"><a class="anchor" href="#stable_task_inputs"></a>3.1. Stable task inputs</h3>
<div class="paragraph">
<p>Imagine that you&#8217;ve just pulled the main branch of your software afresh from version control. CI has already built this particular commit, so the remote cache should be hot: if you ran a build now, every cacheable task should be loaded from cache.</p>
</div>
<div class="paragraph">
<p>For this to work, your cacheable tasks in your local build need to have exactly the same inputs as on CI.
This is only possible if your inputs are stable, i.e. they only depend on the state of the workspace and the tools required by it, e.g. the Java version.</p>
</div>
<div class="paragraph">
<p>It could well be that the inputs to your tasks are dependent on something you cannot control, for example the current time.
This can happen quite easily. For example you decided to add a timestamp to your jar manifests or to a property file on the classpath.
We call these inputs volatile.
Cacheable tasks need to have stable inputs.
If the inputs to a cacheable tasks are not stable then it will never be pulled from the cache and only take up space in the cache backend.</p>
</div>
</div>
<div class="sect2">
<h3 id="concepts_repeatable_task_outputs"><a class="anchor" href="#concepts_repeatable_task_outputs"></a>3.2. Repeatable task outputs</h3>
<div class="paragraph">
<p>Now that you have stable task inputs, image the same situation as before.
Again, you&#8217;ve just pulled the main branch of your software afresh from version control. CI has already built this particular commit, so the remote cache should be hot: if you ran a build now, every cacheable task would be loaded from cache.</p>
</div>
<div class="paragraph">
<p>Consider now making a small change to the inputs of your code generator task. Let&#8217;s make this a change that will not result in any <em>meaningful</em> difference to the code-generator. Maybe add an empty line at the end of a file, or change a comment.</p>
</div>
<div class="paragraph">
<p>Because you&#8217;ve changed its inputs, the code generator task needs to execute again during the next build. However, it will generate <em>exactly the same output</em> as before, so anything that depends on that output will stay up-to-date.</p>
</div>
<div class="paragraph">
<p>However, if your code generator adds a timestamp, the otherwise meaningless change to the code generator&#8217;s inputs <em>will</em> result in different results being produced. Tasks that depend on the code generator&#8217;s output will need to be re-executed. This can result in a cascade of changes rippling through the build, destroying build performance along the way.</p>
</div>
<div class="paragraph">
<p>You can avoid the cascade of change requiring everything to be rebuilt when your task is repeatable.</p>
</div>
</div>
<div class="sect2">
<h3 id="normalization"><a class="anchor" href="#normalization"></a>3.3. Better reuse via input normalization</h3>
<div class="paragraph">
<p>We saw that having stable inputs is crucial for cacheable tasks.
Achieving byte by byte identical inputs for each task can be challenging.
This is where <a href="https://docs.gradle.org/4.0-rc-1/userguide/more_about_tasks.html#sec:configure_input_normalization">input normalization</a> comes into play.
Input normalization is used by Gradle to determine if two task inputs are essentially the same.
Gradle uses normalized inputs when doing up-to-date checks and when determining the build cache key.</p>
</div>
<div class="paragraph">
<p>When comparing two file collections Gradle needs to look at two aspects from each file: the file path and the file contents.
The consumer of the file collection needs to declare what about a file is essential with respect to these two aspects.</p>
</div>
<div class="sect3">
<h4 id="path_sensitivity_and_relocatability"><a class="anchor" href="#path_sensitivity_and_relocatability"></a>3.3.1. Path sensitivity and relocatability</h4>
<div class="paragraph">
<p>Tasks having file collections as inputs can declare the parts of a file path what are essential to them - this is called the <em>path sensitivity</em> of the input.
For example, the class file produced by the Java compiler is dependent on the file name of the Java source file and does not depended on other parts of the file path.
Therefore, the path sensitivity for the sources of the <code>JavaCompile</code> task is <code>NAME_ONLY</code>.
Only the normalized paths of Java sources - the file name - would be considered an input to the <code>JavaCompile</code> task.</p>
</div>
<div class="paragraph">
<p>In order to re-use task outputs between different build machines, the normalized file paths need to agree between tasks of the different workspaces.
This only works if the path sensitivity of its inputs is <code>NONE</code>, <code>NAME_ONLY</code> or <code>RELATIVE</code>.
Absolute paths cannot be relocated between different build machines in general.
Trying to do so would require everyone trying to re-use the outputs built on one machine to have its workspace and all the tools used by the build in the same location.
This is highly impractical. A task or its inputs are called relocateable if all of the file inputs have a relocatable path sensitivity.</p>
</div>
<div class="paragraph">
<p>Cacheable tasks always should be relocatable and we made sure that this is true for all tasks which ship with Gradle.</p>
</div>
</div>
<div class="sect3">
<h4 id="compile_avoidance"><a class="anchor" href="#compile_avoidance"></a>3.3.2. Compile avoidance</h4>
<div class="paragraph">
<p>Java compilation is only affected by changes to the ABI of the compile classpath.
Gradle has a deep understanding of what a compile classpath is and therefore uses a sophisticated normalization strategy for it.
Task outputs can be re-used as long the the ABI of the classes on the compile classpath stays the same.
This enables Gradle to avoid Java compilation by using incremental builds or the build cache.
For more information on compile avoidance see the corresponding section in the <a href="https://docs.gradle.org/4.0-rc-1/userguide/java_plugin.html#sec:java_compile_avoidance">userguide</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="runtime_classpath_normalization"><a class="anchor" href="#runtime_classpath_normalization"></a>3.3.3. Runtime classpath normalization</h4>
<div class="paragraph">
<p>Similar to compile avoidance, Gradle does understand the concept of a runtime classpath and uses a tailored input normalization to avoid running e.g. tests.
For example, for a runtime classpath Gradle inspects the contents of jar files and ignores the timestamps and order of the entries in the jar file.
This means that a rebuilt jar file would be considered the same runtime classpath input.
For details on what level of understanding Gradle has for detecting changes to classpaths see the <a href="https://docs.gradle.org/4.0-rc-1/userguide/more_about_tasks.html#sec:task_input_using_classpath_annotations">userguide</a>.</p>
</div>
<div class="sect4">
<h5 id="filtering"><a class="anchor" href="#filtering"></a>Filtering</h5>
<div class="paragraph">
<p>For a runtime classpath it is even possible to provide better insights to Gradle which files are essential to the input by <a href="https://docs.gradle.org/4.0-rc-1/userguide/more_about_tasks.html#sec:configure_input_normalization">configuring input normalization</a>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say you want to add a file <code>build-info.properties</code> to all your produced jar files which contains volatile information about the build, e.g. the timestamp when the build started or some ID to identify the CI job that published the artifact.
This file is only used for auditing purposes, and has no effect on the outcome of running tests.
Nonetheless, this file is part of the runtime classpath for the <code>test</code> task and changes on every build invocation.
In order to benefit from task output caching again you can add the following configuration to your project.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">normalization {
    runtimeClasspath {
        ignore <span class="string"><span class="delimiter">&quot;</span><span class="content">build-info.properties</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The effect of this configuration would be that changes to <code>build-info.properties</code> would be ignored for up-to-date checks and build cache key calculations.
Note that this will not change the runtime behavior of the <code>test</code> task - i.e. any test is still able to load <code>build-info.properties</code> and the runtime classpath is still the same as before.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="concepts_input_normalization_vs_repeatable_task_outputs"><a class="anchor" href="#concepts_input_normalization_vs_repeatable_task_outputs"></a>3.3.4. Input normalization and repeatable task outputs</h4>
<div class="paragraph">
<p>Input normalization and stable task outputs can both be used to solve the same problem:
Having stable task inputs for tasks which depend on other tasks output.
The difference is that input normalization works on the consumer side - the task consuming the output as an input -
while repeatable task outputs try to solve the problem on the producer side - the task producing the output.</p>
</div>
<div class="paragraph">
<p>Achieving repeatable outputs can be more difficult than using input normalization - especially when Gradle already provides support for the necessary normalization.
Repeatable outputs can also be impossible to achieve for third party tasks which you do not have control on or when you need to include volatile data in your task artifacts for auditing purposes.
Input normalization doesn&#8217;t have these limitation and the same output can be used with different meaning for different consumers.
This is what Gradle already does with respect to runtime and compile classpath.
The same files on the Java classpath are interpreted differently and different kinds of changes are detected.</p>
</div>
<div class="paragraph">
<p>The Gradle team is planning on extending the support for configurable input normalization in future versions of Gradle.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="concepts_overlapping_outputs"><a class="anchor" href="#concepts_overlapping_outputs"></a>3.4. The case against overlapping outputs</h3>
<div class="paragraph">
<p>If two tasks write to the same output directory or output file it is difficult for Gradle to determine which output belongs to which task.
It is also hard to automatically remove stale output files for the same reason.
Tasks which have dedicated output directories which do not overlap are much easier to understand to Gradle.</p>
</div>
<div class="paragraph">
<p>Moreover, task output caching will always restore the whole output directory of a task from the cache.
For this reason, tasks whose output directories overlap with each other cannot be cached and task output caching will be automatically disabled for the task.
Gradle&#8217;s built-in tasks are configured in a way that there will not be any overlapping outputs.</p>
</div>
<div class="paragraph">
<p>Gradle Enterprise will show tasks where caching was disabled for overlapping outputs in the timeline.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/overlapping-outputs-timeline.png" alt="overlapping outputs timeline">
</div>
</div>
</div>
<div class="sect2">
<h3 id="reuse_of_task_outputs_with_the_same_inputs_but_different_task_paths"><a class="anchor" href="#reuse_of_task_outputs_with_the_same_inputs_but_different_task_paths"></a>3.5. Reuse of task outputs with the same inputs, but different task paths</h3>
<div class="paragraph">
<p>Imagine you have two <code>JavaCompile</code> tasks in your build, both operating on the same source files, each of them having a different output directory.
Would you expect that whichever runs second would re-use the outputs of the first task via the build cache?</p>
</div>
<div class="paragraph">
<p>Having two tasks in the same build that do the same is not necessarily something you need to refactor.
Tools like the Android plugin create several tasks for each variant of the project; some of those tasks could potentially do the same thing.
Tying the cached result to the task path would force you to rebuild something that you&#8217;ve already built.</p>
</div>
<div class="paragraph">
<p>We think that the outputs should be re-used since the task path is only a name and does not describe anything essential to the task itself.
This is also why it is possible to see tasks which are loaded from the cache if you run a build even if your build cache was empty before you started the build.</p>
</div>
</div>
<div class="sect2">
<h3 id="non_cacheable_tasks"><a class="anchor" href="#non_cacheable_tasks"></a>3.6. Non-cacheable tasks</h3>
<div class="paragraph">
<p>We&#8217;ve been talking quite a bit about cacheable tasks, which implies there are non-cacheable ones, too. If caching task outputs is as awesome as it sounds, why not cache every task?</p>
</div>
<div class="paragraph">
<p>There are tasks that are definitely worth caching: tasks that do complex, repeatable processing and produce moderate amounts of output. Compilation tasks are usually ideal candidates for caching. At the other end of the spectrum lie I/O-heavy tasks, like <code>Copy</code> and <code>Sync</code>. Moving files around locally typically cannot be sped up by copying them from a cache. If we did so, we would even waste good resources on storing all those redundant results in the cache.</p>
</div>
<div class="paragraph">
<p>Most tasks are either obviously worth caching, or obviously not. For those in-between a good rule of thumb is to see if downloading results would be significantly faster than producing them locally.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="debugging_and_diagnosing_cache_misses"><a class="anchor" href="#debugging_and_diagnosing_cache_misses"></a>4. Debugging and diagnosing cache misses</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For using task output caching efficiently it is essential to keep the balance between specifying all the inputs to your
tasks while not over-specifying them. If you don&#8217;t specify enough of your inputs then your build will be incorrect and you
will share outputs between tasks that should have had a different output. If you specify unnecessary inputs to your tasks,
 you will have cache misses while you could have reused earlier outputs.
 For Gradle&#8217;s built-in tasks we prefer to err on the side of correctness and we suggest that you do the same.</p>
</div>
<div class="paragraph">
<p>This chapter is about finding out why a cache miss was happening. If you have a cache hit which you didn&#8217;t expect we
suggest to declare whatever change you expected to trigger the cache miss as an input to the task.</p>
</div>
<div class="sect2">
<h3 id="how_to_find_problems_with_task_output_caching"><a class="anchor" href="#how_to_find_problems_with_task_output_caching"></a>4.1. How to find problems with task output caching</h3>
<div class="paragraph">
<p>In order to find existing problems with your usage of task output caching you can do a variety of things.</p>
</div>
<div class="paragraph">
<p>First, you should start out with running a fully up-to-date build.
You do not even have to enable the build cache for this exercise.
The expected outcome is that that all incremental tasks are up-to-date.
Tasks which have no output or no inputs will always be executed, but that shouldn&#8217;t be a problem.
If you find some tasks which are out of date then use the methods from <a href="#diagnosing_cache_miss">Diagnosing the reasons for a cache miss</a> to determine the changed inputs for the tasks and use the methods from <a href="#common-problems">Common problems and their solutions</a> to fix those tasks.
The goal is to achieve <a href="#stable_task_inputs">Stable task inputs</a> for cacheable tasks.
If you find a task which is out of date but no cacheable tasks depend on its outcome then you don&#8217;t have to do anything about it.</p>
</div>
<div class="paragraph">
<p>When you are happy with the up-to-date performance then you can repeat the experiment above but this time with a clean build and the build cache turned on.
The goal with clean builds and the build cache turned on is to retrieve all cacheable tasks from the cache.
You should start out simple and use the same checkout for the consumer build.
When you are happy with the performance in the single workspace use-case you can go further:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use different workspaces on the same machine.</p>
</li>
<li>
<p>Use different workspaces on different machines using a remote build cache.</p>
</li>
<li>
<p>Use the cache populated by a CI build and a developer machine.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>After these experiments with fully cache builds you can go on and try to make typical changes to your project and see if enough tasks are still cached.
If the results are not satisfactory you should think about restructuring your project to reduce dependencies between different tasks.</p>
</div>
<div class="paragraph">
<p>We had good experiences with recording execution times of our builds, generate graphs of those and then look at the results.
You then can look for certain patterns, like a rebuilding everything even though you expected compilation to be cached.</p>
</div>
<div class="paragraph">
<p>You can also make certain changes to your code base manually or automatically and check that the expected set of tasks is cached.</p>
</div>
<div class="paragraph">
<p>If these experiments point to a possible problem with your use of task output caching, you would need to go into diagnosing a cache miss as explained below.</p>
</div>
</div>
<div class="sect2">
<h3 id="helpful_data_for_diagnosing_a_cache_miss"><a class="anchor" href="#helpful_data_for_diagnosing_a_cache_miss"></a>4.2. Helpful data for diagnosing a cache miss</h3>
<div class="paragraph">
<p>A cache miss happens when Gradle calculates a build cache key for a task which is different from any of the build cache keys in the cache.
Only comparing the build cache key on its own does not give much information, so we need to look at some finer grained data to be able to diagnose the cache miss.
All the things influencing the build cache key can be found in the <a href="https://docs.gradle.org/4.0-rc-1/userguide/build_cache.html#sec:task_output_caching_details">userguide</a>.</p>
</div>
<div class="paragraph">
<p>Basically, we can compare the following data, listed from coarse grained to fine grained:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Build cache keys</p>
</li>
<li>
<p>Task and Task action implementations</p>
<div class="ulist">
<ul>
<li>
<p>classloader hash</p>
</li>
<li>
<p>class name</p>
</li>
</ul>
</div>
</li>
<li>
<p>Task output property names</p>
</li>
<li>
<p>Individual task property input hashes</p>
</li>
<li>
<p>Hashes of files which are part of task input properties</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Currently, the build cache key for the task is logged at the info level,
while information down to the individual input property level is available in the info log:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Appending taskClass to build cache key: org.gradle.api.tasks.compile.JavaCompile_Decorated
Appending classLoaderHash to build cache key: da6eca52100422099189290bf68f200a
Appending actionType to build cache key: org.gradle.api.internal.project.taskfactory.AbstractOutputPropertyAnnotationHandler$2$1
Appending actionClassLoaderHash to build cache key: 2cdf3f9202925b5befa161030ab43724
Appending actionType to build cache key: org.gradle.api.internal.project.taskfactory.TaskClassValidator
.
.
.
Appending inputPropertyHash for 'classpath' to build cache key: 2b6ab53aa11d4a7d4a1f95a8f78f4d7c
Appending inputPropertyHash for 'effectiveAnnotationProcessorPath' to build cache key: d41d8cd98f00b204e9800998ecf8427e
Appending inputPropertyHash for 'options.sourcepath' to build cache key: d41d8cd98f00b204e9800998ecf8427e
Appending inputPropertyHash for 'source' to build cache key: f6ba49b2466f0090272c43ac5f54ec1d
Appending outputPropertyName to build cache key: destinationDir
Build cache key for task ':compileJava' is 2b220117efa6710f7ab191a0bbe48c00</pre>
</div>
</div>
<div class="paragraph">
<p>If you want to go into the details of finding out e.g. which classes and jar files constitute the <code>classpath</code> for the <code>compileJava</code>
task you need to resort to comparing those files on disk yourself.</p>
</div>
<div class="paragraph">
<p>Luckily, you do not have to capture this data yourself - the build scan plugin already takes care of this for you.
This means that Gradle Enterprise already has the necessary data to diagnose the cache miss when using the build scan plugin.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/task-inputs-comparison.png" alt="task inputs comparison">
</div>
</div>
<div class="paragraph">
<p>Note that it is also possible that task output caching for a cacheable task was disabled.
When this happens the reason why caching was disabled for the task is reported on the info log level and in the build scan.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/caching-disabled.png" alt="caching disabled">
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>TODO:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Add current GE screenshot showing some differences</p>
</li>
</ul>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="diagnosing_cache_miss"><a class="anchor" href="#diagnosing_cache_miss"></a>4.3. Diagnosing the reasons for a cache miss</h3>
<div class="paragraph">
<p>Having the data from the last section at hand, you should be able to diagnose why the outputs of a certain task were not found in the build cache.
Since you were expecting more tasks to be cached, you should be able to pinpoint a build which would have produced the artifact under question.</p>
</div>
<div class="paragraph">
<p>Before diving into how to find out why one task has not been loaded from the cache we should first look into which task caused the cache misses.
There is a cascade effect causing dependent tasks to be executed if one of the tasks earlier in the build is not loaded from the cache and has different outputs.
Therefore, you should therefore at the first cacheable task which was executed and continue investigating there.
This can be done from the timeline view in a build scan or from the task input comparison directly.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/first-non-cached-task.png" alt="first non cached task">
</div>
</div>
<div class="paragraph">
<p>At first, you should check if the implementation of the task changed. This would mean checking the class names and classloader hashes
for the task class itself and for each of its action. If there is a change, this means that the build script, <code>buildSrc</code> or the Gradle version has changed.</p>
</div>
<div class="paragraph">
<p>If the implementation is the same, then you need to start comparing inputs between the two builds.
There should be at least one different input hash. If it is a simple value property, then the configuration of the task changed.
This can happen for example by</p>
</div>
<div class="ulist">
<ul>
<li>
<p>changing the build script,</p>
</li>
<li>
<p>conditionally configuring the task differently for CI or the developer builds,</p>
</li>
<li>
<p>depending on a system property or an environment variable for the task configuration,</p>
</li>
<li>
<p>or having an absolute path which is part of the input.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the changed property is a file property, then the reasons can be the same as for the change of a value property.
Most probably though a file on the filesystem changed in a way that Gradle detects a difference for this input.
The most common case will be that the source code was changed by a check in.
It is also possible that a file generated by a task changed, e.g. since it includes a timestamp.
Note that the Java version can also influence the output of the Java compiler.
If you did not expect the file to be an input to the task, then it is possible that you should alter the configuration of the task to not include it.
For example, having your integration test configuration including all the unit test classes as a dependency has the effect that all integration tests
are re-executed when a unit test changes.
Another option is that the task tracks absolute paths instead of relative paths and the location of the project directory changed on disk.</p>
</div>
</div>
<div class="sect2">
<h3 id="example"><a class="anchor" href="#example"></a>4.4. Example</h3>
<div class="paragraph">
<p>We will walk you through the process of diagnosing a cache miss.
Let&#8217;s say we have build <code>A</code> and build <code>B</code> and we expected all the test tasks for a sub-project <code>sub1</code> to be cached in build <code>B</code> since only a unit test for another sub-project <code>sub2</code> changed.
Actually, all the tests for the sub-project have been executed.
Since we have the cascading effect when we have cache misses, we need to find the task which caused the caching chain to fail.
This can easily be done by filtering for all cacheable tasks which have been executed and then select the first one.
In our case, it turns out that the tests for the sub-project <code>internal-testing</code> were executed even though there was no code change to this project.
We start the input property comparison in Gradle Enterprise and see that the property <code>classpath</code> changed. This means that some file on the runtime classpath actually did change.
Looking deeper into this, we actually see that the inputs for the task <code>processResources</code> changed in that project, too.
Finally, we find this in our build file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task currentVersionInfo() {
    doLast {
        <span class="keyword">def</span> properties = <span class="keyword">new</span> <span class="predefined-type">Properties</span>()
        properties.latestMilestone = version
        properties.store(<span class="keyword">new</span> <span class="predefined-type">File</span>(generatedResourcesDir, <span class="string"><span class="delimiter">&quot;</span><span class="content">currentVersion.properties</span><span class="delimiter">&quot;</span></span>))
    }
}

sourceSets.main.output.dir generatedResourcesDir, <span class="key">builtBy</span>: currentVersionInfo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since properties files stored by Java&#8217;s <code>Properties.store</code> method contain a timestamp, this will cause a change to the runtime classpath every time the build runs.
Note that the compile classpath is not affected since compile avoidance ignores non-class files on the compile classpath.
In order to solve this problem see <a href="#volatile_outputs">Non-repeatable task outputs</a>.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>TODO:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Add GE screenshots</p>
</li>
</ul>
</div>
</blockquote>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="common-problems"><a class="anchor" href="#common-problems"></a>5. Common problems and their solutions</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="system_file_encoding"><a class="anchor" href="#system_file_encoding"></a>5.1. System file encoding</h3>
<div class="paragraph">
<p>Most Java tools use the system file encoding when no specific encoding is specified.
This means that running the same build on machines with different file encoding can yield different outputs.
Currently Gradle only tracks on a per-task basis that no file encoding has been specified, but it does not track the system encoding of the JVM in use.
This can cause incorrect builds. You should always set the file system encoding to avoid these kind of problems.</p>
</div>
</div>
<div class="sect2">
<h3 id="environment_variable_tracking"><a class="anchor" href="#environment_variable_tracking"></a>5.2. Environment variable tracking</h3>
<div class="paragraph">
<p>Gradle does not track changes in environment variables for tasks.
For example for the <code>Test</code> tasks it is completely possible that the outcome depends on a few environment variables.
To ensure that only the right artifacts are re-used between builds, you need to add environment variables as inputs to tasks depending on them.</p>
</div>
<div class="paragraph">
<p>Absolute paths are often passed as environment variables, too. You need to pay attention what you add as an input to the task in this case.
In this case you need to pay special attention to what you add as task inputs.
You would need to ensure that the absolute path is the same between machines. Most times it makes sense to track the file or the contents of the directory the absolute path points to.
If the absolute path represents a tool being used it probably makes sense to track the tool version as an input instead.
&gt; <strong>TODO:</strong>
&gt;
&gt;  - Present examples how to fix these problems, probably using the runtime API</p>
</div>
<div class="paragraph">
<p>If you add conditional logic to distinguish CI builds from local development builds, you have to ensure that this does not break the loading of task outputs from CI onto developer machines.
For example, the following setup would break caching of <code>Test</code> tasks, since Gradle always detects the differences in custom task actions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">if</span> (<span class="predefined-type">System</span>.getenv().containsKey(<span class="string"><span class="delimiter">&quot;</span><span class="content">CI</span><span class="delimiter">&quot;</span></span>) {
    test.doFirst {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Running test on CI</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should always add the action unconditionally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">test.doFirst {
    <span class="keyword">if</span> (<span class="predefined-type">System</span>.getenv().containsKey(<span class="string"><span class="delimiter">&quot;</span><span class="content">CI</span><span class="delimiter">&quot;</span></span>) {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Running test on CI</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This way, the task has the same custom action on CI and on developer builds and its outputs can be re-used if the remaining inputs are the same.</p>
</div>
</div>
<div class="sect2">
<h3 id="line_endings"><a class="anchor" href="#line_endings"></a>5.3. Line endings</h3>
<div class="paragraph">
<p>If you are building on different operating systems be aware that some version control systems convert line endings on check-out.
For example, Git on Windows uses <code>autocrlf=true</code> by default which converts all line endings to <code>\r\n</code>.
As a consequence, compilation outputs can&#8217;t be re-used on Windows since the input sources are different.
If sharing the build cache across multiple operating systems is important in your environment, then setting <code>autocrlf=false</code> across your build machines is crucial for optimal build cache usage.</p>
</div>
</div>
<div class="sect2">
<h3 id="symbolic_links"><a class="anchor" href="#symbolic_links"></a>5.4. Symbolic links</h3>
<div class="paragraph">
<p>Gradle does not store the symbolic link in the build cache but the actual file contents of the destination of the link.
As a consequence you might have a hard time when trying to re-use outputs which heavily use symbolic links.
There currently is no workaround for this behavior.</p>
</div>
</div>
<div class="sect2">
<h3 id="java_version_tracking"><a class="anchor" href="#java_version_tracking"></a>5.5. Java version tracking</h3>
<div class="paragraph">
<p>Gradle does track the major version of Java as an input for compilation and test execution.
Currently, it does neither track the vendor nor the minor version.
Still, the vendor and the minor version may influence the bytecode produced by compilation.</p>
</div>
<div class="paragraph">
<p>If you use different JVM vendors for compiling or running Java we strongly suggest that you add the vendor as an input to the corresponding tasks.
This can be achieved by using the <a href="https://docs.gradle.org/4.0-rc-1/userguide/more_about_tasks.html#sec:task_input_output_runtime_api">runtime API</a> as shown in the following snippet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.withType(AbstractCompile) {
    inputs.property(<span class="string"><span class="delimiter">&quot;</span><span class="content">java.vendor</span><span class="delimiter">&quot;</span></span>) {
        <span class="predefined-type">System</span>.getProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">java.vendor</span><span class="delimiter">&quot;</span></span>)
    }
}

tasks.withType(Test) {
    inputs.property(<span class="string"><span class="delimiter">&quot;</span><span class="content">java.vendor</span><span class="delimiter">&quot;</span></span>) {
        <span class="predefined-type">System</span>.getProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">java.vendor</span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With respect to tracking the Java minor version there are different competing aspects: support pulling results for developers and having "perfect" results on CI. There are basically two situations when you may want to track the minor version of Java: for compilation and for runtime.</p>
</div>
<div class="paragraph">
<p>For compilation we saw sometimes differences in the produced bytecode for different minor versions. The bytecode should still expose the same runtime behavior.
Note that <a href="https://docs.gradle.org/4.0-rc-1/userguide/java_plugin.html#sec:java_compile_avoidance">Java compile avoidance</a> will treat this bytecode the same since it extracts the ABI.</p>
</div>
<div class="paragraph">
<p>Treating the minor number always as an input would it make very hard for developers to pull from the build cache. We saw that even in bigger companies different developers on the same team were using different Java minor versions. If you are able to control the environment in a way that everybody in your team and on CI is using exactly the same Java minor version then we suggest that you add the minor version as an input.</p>
</div>
<div class="paragraph">
<p>Note that even without tracking the Java minor version you may have cache misses for developers due to some locally compiled class files which constitute an input to test execution.
If these outputs made it into the local build cache on this developers machine even a clean will not solve the situation.
Therefore, the choice for tracking the Java minor version is between sometimes or never re-using outputs between different Java minor versions for test execution.</p>
</div>
<div class="paragraph">
<p>Note that the compiler infrastructure provided by the JVM used to run Gradle is also used by the Groovy compiler.
Therefore, you can expect differences in the bytecode of compiled Groovy classes for the same reasons as above and the same suggestions apply.</p>
</div>
</div>
<div class="sect2">
<h3 id="avoid_changing_inputs_external_to_your_build"><a class="anchor" href="#avoid_changing_inputs_external_to_your_build"></a>5.6. Avoid changing inputs external to your build</h3>
<div class="paragraph">
<p>If your build is dependent on external dependencies like binary artifacts or dynamic data from a web page you need to make sure that these inputs are consistent throughout your infrastructure.
When there are some variations between machines then there will be no cache hits.</p>
</div>
<div class="paragraph">
<p>Never re-release a non-changing binary dependency with the same version number but different contents: if this happens with a plugin dependency, you will never be able to explain why you don’t see cache reuse between machines (it’s because they have different versions of that artifact).</p>
</div>
<div class="paragraph">
<p>For changing binary dependencies you would need to pay attention whether the same dependency is used throughout your build pipeline.
You may want to look into the <a href="https://github.com/nebula-plugins/gradle-dependency-lock-plugin">dependency lock plugin</a> or switch to using <a href="https://docs.gradle.org/4.0-rc-1/userguide/composite_builds.html">composite builds</a> instead.</p>
</div>
<div class="paragraph">
<p>The same is true for depending on volatile external resources, for example a list of released versions.
One way of locking the changes would be to check the volatile resource into source control whenever it changes so that the builds only depend on the state in source control and not on the volatile resource itself.</p>
</div>
</div>
<div class="sect2">
<h3 id="suggestions_for_authoring_your_build"><a class="anchor" href="#suggestions_for_authoring_your_build"></a>5.7. Suggestions for authoring your build</h3>
<div class="sect3">
<h4 id="review_usages_of_code_dofirst_code_and_code_dolast_code"><a class="anchor" href="#review_usages_of_code_dofirst_code_and_code_dolast_code"></a>5.7.1. Review usages of <code>doFirst</code> and <code>doLast</code></h4>
<div class="paragraph">
<p>Using <code>doFirst</code> and <code>doLast</code> from a build script on a cacheable tasks ties you to build script changes since the implementation of the closure comes from the build script.
If possible, you should use separate tasks instead.</p>
</div>
<div class="paragraph">
<p>Modifying input or output properties via the runtime API in <code>doFirst</code> is discouraged since these changes will not be detected for up-to-date checks and the build cache.
Even worse, when the task does not execute, then the configuration of the task is actually different from when it executes.
Instead of using <code>doFirst</code> for modifying the inputs consider using a separate tasks to configure the task under question - a so called configure task.
E.g., instead of doing</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">jar {
    doFirst {
        jar.manifest.mainAttributes(<span class="string"><span class="delimiter">'</span><span class="content">Class-Path</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>project(<span class="string"><span class="delimiter">'</span><span class="content">:core</span><span class="delimiter">'</span></span>).jar.archivePath.name<span class="inline-delimiter">}</span></span><span class="content"> </span><span class="inline"><span class="inline-delimiter">${</span>project(<span class="string"><span class="delimiter">'</span><span class="content">:baseServices</span><span class="delimiter">'</span></span>).jar.archivePath.name<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>do</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task configureJar {
    doLast {
        jar.manifest.mainAttributes(<span class="string"><span class="delimiter">'</span><span class="content">Class-Path</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>project(<span class="string"><span class="delimiter">'</span><span class="content">:core</span><span class="delimiter">'</span></span>).jar.archivePath.name<span class="inline-delimiter">}</span></span><span class="content"> </span><span class="inline"><span class="inline-delimiter">${</span>project(<span class="string"><span class="delimiter">'</span><span class="content">:baseServices</span><span class="delimiter">'</span></span>).jar.archivePath.name<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
    }
}

jar.dependsOn(configureJar)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="logic_based_on_task_outcome"><a class="anchor" href="#logic_based_on_task_outcome"></a>5.7.2. Build logic based on the outcome of a task</h4>
<div class="paragraph">
<p>Do not base build logic on whether a task has been <em>executed</em>.
In particular you should not assume that the output of a task can only change if it actually executed.
Actually, loading the outputs from the build cache would also change them.
Instead of relying on custom logic to deal with changes to input or output files you should leverage Gradle&#8217;s built-in support by declaring the correct inputs and outputs for your tasks and leave it to Gradle to decide if the task actions should be executed.
For the very same reason using <code>outputs.upToDateWhen</code> is discouraged and should be replaced by properly declaring the task&#8217;s inputs.</p>
</div>
</div>
<div class="sect3">
<h4 id="overlapping_outputs"><a class="anchor" href="#overlapping_outputs"></a>5.7.3. Overlapping outputs</h4>
<div class="paragraph">
<p>You already saw that overlapping outputs are a problem for task output caching in <a href="#concepts_overlapping_outputs">The case against overlapping outputs</a>.
When you add new tasks to your build or re-configure built-in tasks make sure you do not create overlapping outputs for cacheable tasks.
If you must you can add a <code>Sync</code> task which then would sync the merged outputs into the target directory while the original tasks remain cacheable.</p>
</div>
<div class="paragraph">
<p>Gradle Enterprise will show tasks where caching was disabled for overlapping outputs in the timeline and in the task input comparison.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/overlapping-outputs-input-comparison.png" alt="overlapping outputs input comparison">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="achieving_stable_task_inputs"><a class="anchor" href="#achieving_stable_task_inputs"></a>5.8. Achieving stable task inputs</h3>
<div class="paragraph">
<p>It is crucial to have <a href="#stable_task_inputs">stable task inputs</a> for every cacheable task.
We will go through various situations which violate stable task inputs and look at possible solutions.</p>
</div>
<div class="sect3">
<h4 id="volatile_inputs"><a class="anchor" href="#volatile_inputs"></a>5.8.1. Volatile task inputs</h4>
<div class="paragraph">
<p>If you use a volatile input like a timestamp as an input property for a task, then there is nothing Gradle can do to make the task cacheable.
You should really think hard if the volatile data is really essential to the output or if it is only there for e.g. auditing purposes.</p>
</div>
<div class="paragraph">
<p>If the volatile input is essential to the output then you can try to make the task using the volatile input cheaper to execute.
You can do this by splitting the task into two tasks - the first task doing the expensive work which is cacheable and the second task adding the volatile data to the output.
In this way the output stays the same and the build cache can be used to avoid doing the expensive work.
For example, for building a jar file the expensive part - Java compilation - is already a different task while the jar task itself, which is not cacheable, is cheap.</p>
</div>
<div class="paragraph">
<p>If it is not an essential part of the output, then you should not declare it as an input.
As long as the volatile input does not influence the output then there is nothing else to do.
Most times though, the input will be part of the output.</p>
</div>
</div>
<div class="sect3">
<h4 id="volatile_outputs"><a class="anchor" href="#volatile_outputs"></a>5.8.2. Non-repeatable task outputs</h4>
<div class="paragraph">
<p>Having tasks which generate different outputs for the same inputs can pose a challenge for the effective use of task output caching as seen in <a href="#concepts_repeatable_task_outputs">Repeatable task outputs</a>.
If the non-repeatable task output is not used by any other task then the effect is very limited.
It basically means that pulling the task from the cache might produce a different result than executing the same task locally.
If the only difference between the outputs is a timestamp, then you can either accept the effect of the build cache or decide that the task is not cacheable after all.</p>
</div>
<div class="paragraph">
<p>Non-repeatable task outputs lead to non-stable task inputs as soon as another task depends on the non-repeatable output.
For example, re-creating a jar file from the files with the same contents but different modification times yields a different jar file.
Any other task depending on this jar file as an input file cannot be loaded from the cache when the jar file is rebuilt locally.
This can lead to hard-to-diagnose cache misses when the consuming build is not a clean build or when a cacheable task depends on the output of a non-cacheable task.
For example, when doing incremental builds it is possible that the artifact on disk which is considered up-to-date and the artifact in the build cache are different even though they are essentially the same.
A task depending on this task output would then not be able to load outputs from the build cache since the inputs are not exactly the same.</p>
</div>
<div class="paragraph">
<p>As described <a href="#concepts_input_normalization_vs_repeatable_task_outputs">earlier</a> you can either make the task outputs repeatable or use input normalization.</p>
</div>
<div class="paragraph">
<p>We already talked about the possibilities with input normalization and the possibility to configure input normalization.</p>
</div>
<div class="paragraph">
<p>Gradle includes some support for creating repeatable output for archive tasks.
For tar and zip files Gradle can be configured to create <a href="https://docs.gradle.org/4.0-rc-1/userguide/working_with_files#sec:reproducible_archives">reproducible archives</a>.
This is done by configuring e.g. the <code>Zip</code> task via the following snippet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task createZip(<span class="key">type</span>: Zip) {
    preserveFileTimestamps = <span class="predefined-constant">false</span>
    reproducibleFileOrder = <span class="predefined-constant">true</span>
...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another way to make the outputs repeatable is to activate caching for a task with non-repeatable outputs.
If you can make sure that the same build cache is used for all builds then the task will always have the same outputs for the same inputs by design of the build cache.
Going down this road can lead to different problems with cache misses for incremental builds as described above.
Moreover, race conditions between different builds trying to store the same outputs in the build cache in parallel can lead to hard-to-diagnose cache misses.
If possible, you should avoid going down that route.</p>
</div>
</div>
<div class="sect3">
<h4 id="limit_the_effect_volative_data"><a class="anchor" href="#limit_the_effect_volative_data"></a>5.8.3. Limit the effect volative data</h4>
<div class="paragraph">
<p>If none of the described solutions for dealing with volatile data work for you, you should still be able to limit the effect of volatile data on effective use of the build cache.
This can be done by adding the volatile data later to the outputs as described in <a id="volatile_inputs"></a>.
Another option would be to move the volatile data so it affects less tasks.
For example moving the dependency from the <code>compile</code> to the <code>runtime</code> configuration may already have quite an impact.</p>
</div>
<div class="paragraph">
<p>Sometimes it is also possible to build two artifacts, one containing the volatile data and another one containing a constant representation of the volatile data.
The non-volatile output would be used e.g. for testing while the volatile one would be published to an external repository.
This is in conflict with the Continuous Delivery "build artifacts once" principle but can sometimes be the only option.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="custom_and_third_party_tasks"><a class="anchor" href="#custom_and_third_party_tasks"></a>5.9. Custom and third party tasks</h3>
<div class="paragraph">
<p>If your build contains custom or third party tasks, you should take special care that these don&#8217;t influence the effectiveness of the build cache.
Special care should also be taken for code generation tasks which may not have <a href="#concepts_repeatable_task_outputs">repeatable task outputs</a>.
This can happen if the code generator includes e.g. a timestamp in the generated files or depends on the order of the input files.
Other pitfalls can be the use of `HashMap`s or other data structures without order guarantees in the task&#8217;s code.</p>
</div>
<div class="paragraph">
<p>Note that some third party plugins can even influence cacheability of Gradle&#8217;s built-in tasks.
This can happen if they add inputs like absolute paths or volatile data to tasks via the runtime API.
In the worst case this can lead to incorrect builds when the plugins try to depend on the <a href="#logic_based_on_task_outcome">outcome of a task</a> and do not take <code>FROM-CACHE</code> into account.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="summary"><a class="anchor" href="#summary"></a>6. Summary</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You learned about the two ways Gradle can avoid work and we showed you the concepts which make up a build which is effectively using task output caching.
You should now have the knowledge to adapt your own build so it can make effective use of the build cache.
By doing so, you will improve incremental build performance while having fast clean builds when using the build cache.
Remember, the best way to do work faster is to not do work that doesn’t need doing.</p>
</div>
<div class="paragraph">
<p>Be aware that your journey does not end here.
You should invest into keeping your build well behaved and check manually or automatically that you are still making effective use of the build cache.</p>
</div>
<div class="paragraph">
<p>The Gradle team&#8217;s journey does not end here either.
They will continue improving the build cache and give you more tools to make your builds even faster.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-06-06 14:12:58 UTC
</div>
</div>
</body>
</html>