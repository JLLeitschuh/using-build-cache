<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<title>Build Cache Practices</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
<link rel="stylesheet" href="https://guides.gradle.org/asciidoctor.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,400,700|Source+Code+Pro:500">
<link rel="apple-touch-icon" sizes="180x180" href="https://guides.gradle.org/icon/apple-touch-icon.png">
<link rel="icon" type="image/png" href="https://guides.gradle.org/icon/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="https://guides.gradle.org/icon/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="https://guides.gradle.org/icon/manifest.json">
<link rel="mask-icon" href="https://guides.gradle.org/icon/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="https://guides.gradle.org/icon/favicon.ico">
<meta name="apple-mobile-web-app-title" content="Build Cache Practices">
<meta name="application-name" content="Build Cache Practices">
<meta name="msapplication-config" content="https://guides.gradle.org/icon/browserconfig.xml">
<meta name="theme-color" content="#ffffff">
<script>
  (function(i,s,o,g,r,a,m){i["GoogleAnalyticsObject"]=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,"script","https://www.google-analytics.com/analytics.js","ga");
  ga("create", "UA-4207603-1", "auto");
  ga("send", "pageview");
</script>
</head>
<body class="article toc2 toc-right">
<div id="header"><div style="padding-top: 10px;"><a href="https://guides.gradle.org"><img src="http://guides.gradle.org/gradle-guides.svg" alt=""></a></div><h1>Build Cache Practices</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#use_cases_for_the_build_cache">1. Use cases for the build cache</a>
<ul class="sectlevel2">
<li><a href="#speed_up_developer_builds_with_the_local_cache">1.1. Speed up developer builds with the local cache</a></li>
<li><a href="#share_results_between_ci_builds">1.2. Share results between CI builds</a></li>
<li><a href="#accelerate_developer_builds_by_reusing_ci_results">1.3. Accelerate developer builds by reusing CI results</a></li>
<li><a href="#combine_ci_results_with_local_caching_on_developer_machines">1.4. Combine CI results with local caching on developer machines</a></li>
<li><a href="#share_results_between_developers">1.5. Share results between developers</a></li>
</ul>
</li>
<li><a href="#important_concepts">Important concepts</a>
<ul class="sectlevel1">
<li><a href="#repeatable_task_outcomes">1. Repeatable task outcomes</a></li>
<li><a href="#stable_task_inputs">2. Stable task inputs</a></li>
<li><a href="#normalization">3. Better reuse via input normalization</a>
<ul class="sectlevel2">
<li><a href="#path_sensitivity_and_relocatability">3.1. Path sensitivity and relocatability</a></li>
<li><a href="#compile_avoidance">3.2. Compile avoidance</a></li>
<li><a href="#runtime_classpath_normalization">3.3. Runtime classpath normalization</a></li>
</ul>
</li>
<li><a href="#the_case_against_overlapping_outputs">4. The case against overlapping outputs</a></li>
<li><a href="#debugging_and_diagnosing_cache_misses">5. Debugging and diagnosing cache misses</a>
<ul class="sectlevel2">
<li><a href="#how_to_find_problems_with_task_output_caching">5.1. How to find problems with task output caching</a></li>
<li><a href="#helpful_data_for_diagnosing_a_cache_miss">5.2. Helpful data for diagnosing a cache miss</a></li>
<li><a href="#diagnosing_the_reasons_for_a_cache_miss">5.3. Diagnosing the reasons for a cache miss</a></li>
<li><a href="#example">5.4. Example</a></li>
</ul>
</li>
<li><a href="#common_problems_and_their_solutions">6. Common problems and their solutions</a>
<ul class="sectlevel2">
<li><a href="#system_file_encoding">6.1. System file encoding</a></li>
<li><a href="#environment_variable_tracking">6.2. Environment variable tracking</a></li>
<li><a href="#line_endings">6.3. Line endings</a></li>
<li><a href="#symbolic_links">6.4. Symbolic links</a></li>
<li><a href="#java_version_tracking">6.5. Java version tracking</a></li>
<li><a href="#avoid_changing_inputs_external_to_your_build">6.6. Avoid changing inputs external to your build</a></li>
<li><a href="#suggestions_for_authoring_your_build">6.7. Suggestions for authoring your build</a></li>
</ul>
</li>
<li><a href="#summary">7. Summary</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The best way to do work faster is to not do work that doesn’t need doing. Gradle has two main mechanisms to avoid work at the task level:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>incremental build</strong> avoids running a task if its inputs and outputs are equivalent to what they were during its previous execution,</p>
</li>
<li>
<p><strong>task output caching</strong> reuses task outputs produced with the same inputs anytime before, on any machine that is connected to the same build cache backend.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This guide covers the different use cases for Gradle’s build cache, from local-only development to caching task outputs across large teams. We will discuss ways to measure the advantages provided by the build cache, and methods to improve cache performance, or to diagnose and fix common problems. Let’s dive in!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="use_cases_for_the_build_cache"><a class="anchor" href="#use_cases_for_the_build_cache"></a>1. Use cases for the build cache</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gradle’s build cache is a versatile feature that can be used in different ways.</p>
</div>
<div class="sect2">
<h3 id="speed_up_developer_builds_with_the_local_cache"><a class="anchor" href="#speed_up_developer_builds_with_the_local_cache"></a>1.1. Speed up developer builds with the local cache</h3>
<div class="paragraph">
<p>Even when used by a single developer only, the build cache can be pretty useful. Gradle&#8217;s <em>incremental build</em> feature helps avoid work that is already done, but once you change the inputs of a task, it forgets any previous results. When you are switching branches back and forth, the local results get rebuilt over and over again, even if you are building something that has already been built before. The build cache remembers, though, and heavily reduces the need to rebuild things when they were already built locally. In general it&#8217;s very useful when you need to rebuild different commits, like when running <code>git bisect</code>.</p>
</div>
<div class="paragraph">
<p>The local cache can also be useful when working with a project that has multiple variants dimensions, like in the case of Android applications. Each variant has a number of tasks associated with it, and some of those task variants, despite having different names, can end up doing the same things. With the local cache enabled reuse between task variants will happen automatically when applicable.</p>
</div>
</div>
<div class="sect2">
<h3 id="share_results_between_ci_builds"><a class="anchor" href="#share_results_between_ci_builds"></a>1.2. Share results between CI builds</h3>
<div class="paragraph">
<p>The build cache can do more than going back-and-forth in time: it can also bridge physical distance between computers, allowing to reuse results generated on one machine to be reused by another.</p>
</div>
<div class="paragraph">
<p>A usual first step when introducing the build cache within a team is to enable it for CI builds only. Using a shared HTTP build cache backend (such as <a href="https://gradle.com/build-cache/">the one provided by Gradle Enterprise</a> can significantly reduce the work CI executors need to do. This translates into faster feedback to developers, and less money spent on the CI infrastructure.</p>
</div>
<div class="paragraph">
<p>Using the build cache on CI first makes sense as CI environment is usually easier to control than developer machines. It helps shake out issues with the build that hurt cacheability.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>TODO:</strong> Discus audit requirements.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="accelerate_developer_builds_by_reusing_ci_results"><a class="anchor" href="#accelerate_developer_builds_by_reusing_ci_results"></a>1.3. Accelerate developer builds by reusing CI results</h3>
<div class="paragraph">
<p>When multiple developers work on the same project, they don&#8217;t just need to build their own changes: whenever they pull from version control, they end up having to build each others' changes as well. If the pulled changes are sufficiently independent, the developer can safely reuse outputs already generated on CI. Say, you&#8217;re working on module "A", and you pull in some changes to module "B" (which does not depend on your module). If those changes were already built in CI, you can download the task outputs for module "B" from the cache instead of generating them locally.</p>
</div>
<div class="paragraph">
<p>The changes don&#8217;t need to be completely independent, either; we&#8217;ll take a look at the strategies to reuse results when dependencies are involved in the section about the <a href="#normalization">different forms of normalization</a>.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>TODO:</strong> Mention moving a Git tag to the latest published commit can help reduce problems with developers pulling too fresh changes.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="combine_ci_results_with_local_caching_on_developer_machines"><a class="anchor" href="#combine_ci_results_with_local_caching_on_developer_machines"></a>1.4. Combine CI results with local caching on developer machines</h3>
<div class="paragraph">
<p>Developers can utilize both a local and a remote cache. While pulling results from a CI-filled remote cache helps to avoid work needed because of changes by other developers, the local cache can speed up switching branches and doing <code>git bisect</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="share_results_between_developers"><a class="anchor" href="#share_results_between_developers"></a>1.5. Share results between developers</h3>
<div class="paragraph">
<p>Using the local cache is a sort of one-to-one thing, while the HTTP cache typically has a one-to-many topology. Gradle also allows the use of distributed caches, for example with using the <a href="https://github.com/gradle/gradle-hazelcast-plugin/">Hazelcast cache backend</a>.</p>
</div>
<div class="paragraph">
<p>It is also possible to allow developers to upload their results to a shared cache, thus making them available for everyone else, even before CI had a chance to build them.</p>
</div>
<div class="paragraph">
<p>While sharing results from developer machines seems like a good idea at first sight, it might not always be what you are looking for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The environment on developer machines is usually not as strictly controlled as it is on CI. Gradle tries to track every relevant bit of information that can influence a task&#8217;s output, but if there are tasks that are incorrectly defined, developers can pollite the cache with corrupted results.</p>
</li>
<li>
<p>Gradle is in general sage to be used with incremental builds. However, we recommend only uploading to a shared cache from <code>clean</code> builds.</p>
</li>
<li>
<p>Developers can make changes to task outputs while the task is running even unintentionally, or even unknowingly, like continuing making changes in their IDEs while the build is running. Currently Gradle has no good way to defend against these changes, and will simply cache whatever is in the output directory once the task is finished. This again can lead to corrupted results being uploaded to the shared cache.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<h1 id="important_concepts" class="sect0"><a class="anchor" href="#important_concepts"></a>Important concepts</h1>
<div class="sect1">
<h2 id="repeatable_task_outcomes"><a class="anchor" href="#repeatable_task_outcomes"></a>1. Repeatable task outcomes</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="stable_task_inputs"><a class="anchor" href="#stable_task_inputs"></a>2. Stable task inputs</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="normalization"><a class="anchor" href="#normalization"></a>3. Better reuse via input normalization</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="path_sensitivity_and_relocatability"><a class="anchor" href="#path_sensitivity_and_relocatability"></a>3.1. Path sensitivity and relocatability</h3>

</div>
<div class="sect2">
<h3 id="compile_avoidance"><a class="anchor" href="#compile_avoidance"></a>3.2. Compile avoidance</h3>

</div>
<div class="sect2">
<h3 id="runtime_classpath_normalization"><a class="anchor" href="#runtime_classpath_normalization"></a>3.3. Runtime classpath normalization</h3>
<div class="sect3">
<h4 id="filtering"><a class="anchor" href="#filtering"></a>3.3.1. Filtering</h4>

</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the_case_against_overlapping_outputs"><a class="anchor" href="#the_case_against_overlapping_outputs"></a>4. The case against overlapping outputs</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="debugging_and_diagnosing_cache_misses"><a class="anchor" href="#debugging_and_diagnosing_cache_misses"></a>5. Debugging and diagnosing cache misses</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For using task output caching efficiently it is essential to keep the balance between specifying all the inputs to your
tasks while not over-specifying them. If you don&#8217;t specify enough of your inputs then your build will be incorrect and you
will share outputs between tasks that should have had a different output. If you specify unnecessary inputs to your tasks,
 you will have cache misses while you could have reused earlier outputs.
 For Gradle&#8217;s built-in tasks we prefer to err on the side of correctness and we suggest that you do the same.</p>
</div>
<div class="paragraph">
<p>This chapter is about finding out why a cache miss was happening. If you have a cache hit which you didn&#8217;t expect we
suggest to declare whatever change you expected to trigger the cache miss as an input to the task.</p>
</div>
<div class="sect2">
<h3 id="how_to_find_problems_with_task_output_caching"><a class="anchor" href="#how_to_find_problems_with_task_output_caching"></a>5.1. How to find problems with task output caching</h3>
<div class="paragraph">
<p>In order to find existing problems with your usage of task output caching you can do a variety of things.</p>
</div>
<div class="paragraph">
<p>For example you can run a build with the same commit and check that this build is fully cached.
You probably should make sure that the project and the home directory changes between these builds to detect relocatability problems.</p>
</div>
<div class="paragraph">
<p>We had good experiences with recording execution times of our builds, generate graphs of those and then look at the results.
You then can look for certain patterns, like a rebuilding everything even though you expected compilation to be cached.</p>
</div>
<div class="paragraph">
<p>You can also make certain changes to your code base manually or automatically and check that the expected set of tasks is cached.</p>
</div>
<div class="paragraph">
<p>If these experiments point to a possible problem with your use of task output caching, you would need to go into diagnosing a cache miss as explained below.</p>
</div>
</div>
<div class="sect2">
<h3 id="helpful_data_for_diagnosing_a_cache_miss"><a class="anchor" href="#helpful_data_for_diagnosing_a_cache_miss"></a>5.2. Helpful data for diagnosing a cache miss</h3>
<div class="paragraph">
<p>A cache miss happens when Gradle calculates a build cache key for a task which is different from any of the build cache keys in the cache.
Only comparing the build cache key on its own does not give much information, so we need to look at some finer grained data to be able to diagnose the cache miss.
All the things influencing the build cache key can be found in the <a href="https://docs.gradle.org/3.5/userguide/build_cache.html#sec:task_output_caching_details">userguide</a>.</p>
</div>
<div class="paragraph">
<p>Basically, we can compare the following data, listed from coarse grained to fine grained:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Build cache keys</p>
</li>
<li>
<p>Task and Task action implementation inputs</p>
</li>
<li>
<p>classloader hash</p>
</li>
<li>
<p>class name</p>
</li>
<li>
<p>Individual task property input hashes</p>
</li>
<li>
<p>Hashes of files which are part of task input properties</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Currently, the build cache key for the task is logged at the info level,
while information down to the individual input property level is available in the info log:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Appending taskClass to build cache key: org.gradle.api.tasks.compile.JavaCompile_Decorated
Appending classLoaderHash to build cache key: da6eca52100422099189290bf68f200a
Appending actionType to build cache key: org.gradle.api.internal.project.taskfactory.AbstractOutputPropertyAnnotationHandler$2$1
Appending actionClassLoaderHash to build cache key: 2cdf3f9202925b5befa161030ab43724
Appending actionType to build cache key: org.gradle.api.internal.project.taskfactory.TaskClassValidator
.
.
.
Appending inputPropertyHash for 'classpath' to build cache key: 2b6ab53aa11d4a7d4a1f95a8f78f4d7c
Appending inputPropertyHash for 'effectiveAnnotationProcessorPath' to build cache key: d41d8cd98f00b204e9800998ecf8427e
Appending inputPropertyHash for 'options.sourcepath' to build cache key: d41d8cd98f00b204e9800998ecf8427e
Appending inputPropertyHash for 'source' to build cache key: f6ba49b2466f0090272c43ac5f54ec1d
Appending outputPropertyName to build cache key: destinationDir
Build cache key for task ':compileJava' is 2b220117efa6710f7ab191a0bbe48c00</pre>
</div>
</div>
<div class="paragraph">
<p>If you want to go into the details of finding out e.g. which classes and jar files constitute the <code>classpath</code> for the <code>compileJava</code>
task you need to resort to comparing those files on disks yourself.</p>
</div>
<div class="paragraph">
<p>Luckily, you do not have to capture this data yourself - the build scan plugin already takes care of this for you.
This means that Gradle Enterprise already has the necessary data to diagnose the cache miss when using the build scan plugin.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/task-inputs-comparison.png" alt="task inputs comparison">
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>TODO:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Add current GE screenshot showing some differences</p>
</li>
</ul>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="diagnosing_the_reasons_for_a_cache_miss"><a class="anchor" href="#diagnosing_the_reasons_for_a_cache_miss"></a>5.3. Diagnosing the reasons for a cache miss</h3>
<div class="paragraph">
<p>Having the data from the last section at hand, you should be able to diagnose why the outputs of a certain task were not found in the build cache.
Since you were expecting more tasks to be cached, you should be able to pinpoint a build which would have produced the artifact under question.</p>
</div>
<div class="paragraph">
<p>Before diving into how to find out why one task has not been loaded from the cache we should first look into which task caused the cache misses.
There is a cascade effect causing dependent tasks to be executed if one of the tasks earlier in the build is not loaded from the cache and has different outputs.
You should therefore look at the first cacheable task which was executed and continue investigating there.</p>
</div>
<div class="paragraph">
<p>At first, you should check if the implementation of the task changed. This would mean checking the class names and classloader hashes
for the task class itself and for each of its action. If there is a change, this means that the build script, <code>buildSrc</code> or the Gradle version has changed.</p>
</div>
<div class="paragraph">
<p>If the implementation is the same, then you need to start comparing inputs between the two builds.
There should be at least one different input hash. If it is a simple value property, then the configuration of the task changed.
This can happen for example by</p>
</div>
<div class="ulist">
<ul>
<li>
<p>changing the build script,</p>
</li>
<li>
<p>conditionally configuring the task differently for CI or the developer builds,</p>
</li>
<li>
<p>depending on a system property or an environment variable for the task configuration,</p>
</li>
<li>
<p>or having an absolute path is part of the input.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the changed property is a file property, then the reasons can be the same as for the change of a value property.
Most probably though a file on the filesystem changed in a way that Gradle detects a difference for this input.
The most common case will be that the source code was changed by a check in.
It is also possible that a file generated by Gradle changed, e.g. since it includes a timestamp.
Note that the Java version can also influence the output of the Java compiler.
If you did not expect the file to be an input to the task, then it is possible that you should alter the configuration of the task to not include it.
For example, having your integration test configuration including all the unit test classes as a dependency has the effect that all integration tests
are re-executed when a unit test changes.
Another option is that the task tracks absolute paths instead of relative paths and the location of the project directory changed on disk.</p>
</div>
</div>
<div class="sect2">
<h3 id="example"><a class="anchor" href="#example"></a>5.4. Example</h3>
<div class="paragraph">
<p>We will walk you through the process of diagnosing a cache miss.
Let&#8217;s say we have build <code>A</code> and build <code>B</code> and we expected all the test tasks for a sub-project <code>sub1</code> to be cached in build <code>B</code> since only a unit test for another sub-project <code>sub2</code> changed.
Actually, all the tests for the sub-project have been executed.
Since we have the cascading effect when we have cache misses, we need to find the task which caused the caching chain to fail.
This can easily be done by filtering for all cacheable tasks which have been executed and then select the first one.
In our case, it turns out that the tests for the sub-project <code>internal-testing</code> were executed even though there was no code change to this project.
We start the input property comparison in GE and see that the property <code>classpath</code> changed. This means that some file on the runtime classpath actually did change.
Looking deeper into this, we actually see that the inputs for the task <code>processResources</code> changed in that project, too.
Finally, we find this in our build file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task currentVersionInfo() {
    doLast {
        <span class="keyword">def</span> properties = <span class="keyword">new</span> <span class="predefined-type">Properties</span>()
        properties.latestMilestone = version
        properties.store(<span class="keyword">new</span> <span class="predefined-type">File</span>(generatedResourcesDir, <span class="string"><span class="delimiter">&quot;</span><span class="content">currentVersion.properties</span><span class="delimiter">&quot;</span></span>))
    }
}

sourceSets.main.output.dir generatedResourcesDir, <span class="key">builtBy</span>: currentVersionInfo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since a properties files stored by Java&#8217;s <code>Properties.store</code> method contains a timestamp, this will cause a change to the runtime classpath every time the build runs.
Note that the compile classpath is not affected since compile avoidance ignores non-class files on the compile classpath.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>TODO:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Add GE screenshots</p>
</li>
<li>
<p>Point to section on dealing with volatile inputs</p>
</li>
</ul>
</div>
</blockquote>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="common_problems_and_their_solutions"><a class="anchor" href="#common_problems_and_their_solutions"></a>6. Common problems and their solutions</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="system_file_encoding"><a class="anchor" href="#system_file_encoding"></a>6.1. System file encoding</h3>
<div class="paragraph">
<p>Most Java tools use the system file encoding when no specific encoding is specified.
This means that running the same build on machines with different file encoding can yield different outputs.
Gradle currently does only track that no file encoding has been specified on a task basis - but it does not track the system encoding of the JVM it is using.
This can cause incorrect builds. You should always set the file system encoding to avoid these kind of problems.</p>
</div>
</div>
<div class="sect2">
<h3 id="environment_variable_tracking"><a class="anchor" href="#environment_variable_tracking"></a>6.2. Environment variable tracking</h3>
<div class="paragraph">
<p>Gradle does currently not track environment variables for tasks.
For example for the <code>Test</code> tasks it is completely possible that the outcome depends on a few environment variables.
To ensure that only the right artifacts are re-used between builds you need to add environment variables as an input to the tasks depending on them.</p>
</div>
<div class="paragraph">
<p>Absolute paths are often passed as environment variables, too. You need to pay attention what you add as an input to the task in this case. If you add the absolute path then it will be very hard to re-use task outputs between different machines.
You would need to ensure that the absolute path is the same between machines. Most times it makes sense to track the file or the contents of the directory the absolute path points to.
If the absolute path represents a tool being used it probably makes sense to track the tool version as an input instead.</p>
</div>
<div class="paragraph">
<p>If you are adding conditional logic whether you are building on CI or on a developer machine make sure that this does not break loading task outputs on developer machines from CI.
For example, the following setup would break caching of <code>Test</code> tasks, since Gradle always would detect the difference in custom task actions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">if</span> (<span class="predefined-type">System</span>.getenv().containsKey(<span class="string"><span class="delimiter">&quot;</span><span class="content">CI</span><span class="delimiter">&quot;</span></span>) {
    test.doFirst {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Running test on CI</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should always add the action unconditionally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">test.doFirst {
    <span class="keyword">if</span> (<span class="predefined-type">System</span>.getenv().containsKey(<span class="string"><span class="delimiter">&quot;</span><span class="content">CI</span><span class="delimiter">&quot;</span></span>) {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Running test on CI</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This way, both the task has the same custom action on CI and on developer builds and its outputs can be re-used if the remaining inputs are the same.</p>
</div>
</div>
<div class="sect2">
<h3 id="line_endings"><a class="anchor" href="#line_endings"></a>6.3. Line endings</h3>
<div class="paragraph">
<p>If you are building on different operating systems be aware that some version control systems convert line endings on check-out.
For example git on Windows by default uses <code>autocrlf=true</code> which converts all line endings to <code>\r\n</code>.
As a consequence, compilation outputs can&#8217;t be re-used on Windows since the input sources are different.
You should make sure that <code>autocrlf=false</code> across your build machines to ensure optimal build cache usage.</p>
</div>
</div>
<div class="sect2">
<h3 id="symbolic_links"><a class="anchor" href="#symbolic_links"></a>6.4. Symbolic links</h3>
<div class="paragraph">
<p>Gradle does not store the symbolic link in the build cache but the actual file contents of the destination of the link.
As a consequence you might have a hard time when trying to re-use outputs which heavily use symbolic links.
There currently is no workaround for this behavior.</p>
</div>
</div>
<div class="sect2">
<h3 id="java_version_tracking"><a class="anchor" href="#java_version_tracking"></a>6.5. Java version tracking</h3>
<div class="paragraph">
<p>Gradle does track the major version of Java as an input for compilation and test execution.
Currently, it does neither track the vendor nor the minor version.
Still, the vendor and the minor version may influence the bytecode produced by compilation.</p>
</div>
<div class="paragraph">
<p>If you use different JVM vendors for compiling or running Java we strongly suggest that you add the vendor as an input to the corresponding tasks.
This can be achieved by using the <a href="https://docs.gradle.org/3.5/userguide/more_about_tasks.html#sec:task_input_output_runtime_api">runtime API</a> as shown in the following snippet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.withType(AbstractCompile) {
    inputs.property(<span class="string"><span class="delimiter">&quot;</span><span class="content">java.vendor</span><span class="delimiter">&quot;</span></span>) {
        <span class="predefined-type">System</span>.getProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">java.vendor</span><span class="delimiter">&quot;</span></span>)
    }
}

tasks.withType(Test) {
    inputs.property(<span class="string"><span class="delimiter">&quot;</span><span class="content">java.vendor</span><span class="delimiter">&quot;</span></span>) {
        <span class="predefined-type">System</span>.getProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">java.vendor</span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With respect to tracking the Java minor version there are different competing aspects: support pulling results for developers and having "perfect" results on CI. There are basically two situations when you may want to track the minor version number of Java: compilation and for runtime.</p>
</div>
<div class="paragraph">
<p>For compilation we saw sometimes differences in the produced bytecode for different minor version numbers. The bytecode should still expose the same runtime behavior.
Note that <a href="https://docs.gradle.org/3.5/userguide/java_plugin.html#sec:java_compile_avoidance">Java compile avoidance</a> will treat this bytecode the same since it extracts the ABI.</p>
</div>
<div class="paragraph">
<p>Treating the minor number always as an input would it make very hard for developers to pull from the build cache. We saw that even in bigger companies different developers on the same team were using different Java minor versions. If you are able to control the environment in a way that everybody in your team and on CI is using exactly the same Java minor version then we suggest that you add the minor version as an input.</p>
</div>
<div class="paragraph">
<p>Note that even without tracking the Java minor version you may have cache misses for developers due to some locally compiled class files which constitute an input to test execution.
If these outputs made it into the local build cache on this developers machine even a clean will not solve this situation.
Therefore, the choice for tracking the Java minor version is between sometimes or never re-using outputs between for test execution between different Java minor versions.</p>
</div>
<div class="paragraph">
<p>Note that the compiler infrastructure provided by the JVM used to run Gradle is also used by the Groovy compiler.
Therefore, you can expect differences in the bytecode of compiled Groovy classes for the same reasons as above and the same suggestions apply.</p>
</div>
</div>
<div class="sect2">
<h3 id="avoid_changing_inputs_external_to_your_build"><a class="anchor" href="#avoid_changing_inputs_external_to_your_build"></a>6.6. Avoid changing inputs external to your build</h3>
<div class="paragraph">
<p>If your build is dependent on external dependencies like binary artifacts or dynamic data from a web page you need to make sure that these inputs are consistent throughout your infrastructure.
When there are some variations between machines then there will be no cache hits.</p>
</div>
<div class="paragraph">
<p>Never re-release a non-changing binary dependency with the same version number but different contents: if this happens with a plugin dependency, you will never be able to explain why you don’t see cache reuse between machines (it’s because they have different versions of that artifact).</p>
</div>
<div class="paragraph">
<p>For changing binary dependencies you would need to pay attention whether the same dependency is used throughout your build pipeline.
You may want to look into the <a href="https://github.com/nebula-plugins/gradle-dependency-lock-plugin">dependency lock plugin</a> or switch to using <a href="https://docs.gradle.org/3.5/userguide/composite_builds.html">composite builds</a> instead.</p>
</div>
<div class="paragraph">
<p>The same is true for depending on volatile external resources, for example a list of released versions.
One way of locking the changes would be to check in the volatile resource whenever it changes so that the builds only depend on the state in source control and not on the volatile resource itself.</p>
</div>
</div>
<div class="sect2">
<h3 id="suggestions_for_authoring_your_build"><a class="anchor" href="#suggestions_for_authoring_your_build"></a>6.7. Suggestions for authoring your build</h3>
<div class="sect3">
<h4 id="review_usages_of_code_dofirst_code"><a class="anchor" href="#review_usages_of_code_dofirst_code"></a>6.7.1. Review usages of <code>doFirst</code></h4>
<div class="paragraph">
<p>Using <code>doFirst</code> from a build script on a cacheable tasks ties you to build script changes since the implementation of the closure comes from the build script.
If possible, you should use a separate tasks instead.</p>
</div>
<div class="paragraph">
<p>Modifying inputs or output properties via the runtime API in <code>doFirst</code> is discouraged since these changes will not be detected for up-to-date checks and the build cache.
Even worse, when the task does not execute then the configuration of the task is actually different from when it executes.
Instead of using <code>doFirst</code> for modifying the inputs consider using a separate tasks to configure the task under question - a so called configure task.
E.g., instead of doing</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">jar {
    doFirst {
        jar.manifest.mainAttributes(<span class="string"><span class="delimiter">'</span><span class="content">Class-Path</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>project(<span class="string"><span class="delimiter">'</span><span class="content">:core</span><span class="delimiter">'</span></span>).jar.archivePath.name<span class="inline-delimiter">}</span></span><span class="content"> </span><span class="inline"><span class="inline-delimiter">${</span>project(<span class="string"><span class="delimiter">'</span><span class="content">:baseServices</span><span class="delimiter">'</span></span>).jar.archivePath.name<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>do</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task configureJar {
    doLast {
        jar.manifest.mainAttributes(<span class="string"><span class="delimiter">'</span><span class="content">Class-Path</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>project(<span class="string"><span class="delimiter">'</span><span class="content">:core</span><span class="delimiter">'</span></span>).jar.archivePath.name<span class="inline-delimiter">}</span></span><span class="content"> </span><span class="inline"><span class="inline-delimiter">${</span>project(<span class="string"><span class="delimiter">'</span><span class="content">:baseServices</span><span class="delimiter">'</span></span>).jar.archivePath.name<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
    }
}

jar.dependsOn(configureJar)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="build_logic_based_on_the_outcome_of_a_task"><a class="anchor" href="#build_logic_based_on_the_outcome_of_a_task"></a>6.7.2. Build logic based on the outcome of a task</h4>
<div class="paragraph">
<p>Do not base build logic on whether a task has been <em>executed</em>.
In particular you should not assume that the output of a task can only change if it did actually execute.
The outputs could have been loaded from the build cache, too.
In general, you should work together Gradle&#8217;s up-to-date checks since this will ensure that task output caching has the same view of the task.
Using <code>outputs.upToDateWhen</code> is discouraged and should be better modelled by adding the right inputs to the task.</p>
</div>
</div>
<div class="sect3">
<h4 id="no_overlapping_outputs"><a class="anchor" href="#no_overlapping_outputs"></a>6.7.3. No overlapping outputs</h4>
<div class="paragraph">
<p>If two tasks write to the same output directory or output file they cannot be cached and task output caching will be automatically disabled for the task.
Gradle&#8217;s built-in tasks are configured in a way that there will not be any overlapping outputs.
When you add new tasks to your build or re-configure built-in tasks make sure you do not create overlapping outputs for cacheable tasks.
If you must you can add a <code>Sync</code> task which then would sync the merged outputs into the target directory while the original tasks remain cacheable.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="summary"><a class="anchor" href="#summary"></a>7. Summary</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>TBC</strong></p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-05-29 17:19:56 UTC
</div>
</div>
</body>
</html>