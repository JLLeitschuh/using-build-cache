<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<meta name="author" content="Stefan Wolf, Lóránt Pintér">
<title>Using the Build Cache</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
<link rel="stylesheet" href="https://guides.gradle.org/asciidoctor.css">
<link rel="stylesheet" href="css/build-cache-guide.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,400,700|Source+Code+Pro:500">
<link rel="apple-touch-icon" sizes="180x180" href="https://guides.gradle.org/icon/apple-touch-icon.png">
<link rel="icon" type="image/png" href="https://guides.gradle.org/icon/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="https://guides.gradle.org/icon/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="https://guides.gradle.org/icon/manifest.json">
<link rel="mask-icon" href="https://guides.gradle.org/icon/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="https://guides.gradle.org/icon/favicon.ico">
<meta name="apple-mobile-web-app-title" content="Build Cache Practices">
<meta name="application-name" content="Build Cache Practices">
<meta name="msapplication-config" content="https://guides.gradle.org/icon/browserconfig.xml">
<meta name="theme-color" content="#ffffff">
<script defer src="https://guides.gradle.org/js/set-time-to-complete-text.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i["GoogleAnalyticsObject"]=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,"script","https://www.google-analytics.com/analytics.js","ga");
  ga("create", "UA-4207603-1", "auto");
  ga("send", "pageview");
</script>
</head>
<body class="article toc2 toc-right">
<div id="header"><div style="padding-top: 10px;"><a href="https://guides.gradle.org"><img src="http://guides.gradle.org/gradle-guides.svg" alt=""></a></div><h1>Using the Build Cache</h1>
<div class="details">
<span id="author" class="author">Stefan Wolf, Lóránt Pintér</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#use_cases_for_the_build_cache">1. Use cases for the build cache</a>
<ul class="sectlevel2">
<li><a href="#speed_up_developer_builds_with_the_local_cache">1.1. Speed up developer builds with the local cache</a></li>
<li><a href="#share_results_between_ci_builds">1.2. Share results between CI builds</a></li>
<li><a href="#accelerate_developer_builds_by_reusing_ci_results">1.3. Accelerate developer builds by reusing CI results</a></li>
<li><a href="#combine_ci_results_with_local_caching_on_developer_machines">1.4. Combine CI results with local caching on developer machines</a></li>
<li><a href="#share_results_between_developers">1.5. Share results between developers</a></li>
</ul>
</li>
<li><a href="#build_cache_performance">2. Build cache performance</a>
<ul class="sectlevel2">
<li><a href="#fully_cached_builds">2.1. Fully cached builds</a></li>
<li><a href="#cache_impact_on_ci_builds">2.2. Cache impact on CI builds</a></li>
<li><a href="#measuring_developer_builds">2.3. Measuring developer builds</a></li>
</ul>
</li>
<li><a href="#important_concepts">3. Important concepts</a>
<ul class="sectlevel2">
<li><a href="#concepts_repeatable_task_outputs">3.1. Repeatable task outputs</a></li>
<li><a href="#stable_task_inputs">3.2. Stable task inputs</a></li>
<li><a href="#normalization">3.3. Better re-use via input normalization</a></li>
<li><a href="#concepts_overlapping_outputs">3.4. The case against overlapping outputs</a></li>
<li><a href="#re_use_of_outputs_between_different_tasks">3.5. Re-use of outputs between different tasks</a></li>
<li><a href="#non_cacheable_tasks">3.6. Non-cacheable tasks</a></li>
</ul>
</li>
<li><a href="#caching_java_projects">4. Caching Java projects</a>
<ul class="sectlevel2">
<li><a href="#java_compilation">4.1. Java compilation</a></li>
<li><a href="#unit_test_execution">4.2. Unit test execution</a></li>
<li><a href="#integration_test_execution">4.3. Integration test execution</a></li>
<li><a href="#caching_code_buildsrc_code">4.4. Caching <code>buildSrc</code></a></li>
</ul>
</li>
<li><a href="#debugging_and_diagnosing_cache_misses">5. Debugging and diagnosing cache misses</a>
<ul class="sectlevel2">
<li><a href="#finding_problems">5.1. Finding problems with task output caching</a></li>
<li><a href="#helpful_data_for_diagnosing_a_cache_miss">5.2. Helpful data for diagnosing a cache miss</a></li>
<li><a href="#diagnosing_cache_miss">5.3. Diagnosing the reasons for a cache miss</a></li>
<li><a href="#example">5.4. Example</a></li>
</ul>
</li>
<li><a href="#common-problems">6. Solving common problems</a>
<ul class="sectlevel2">
<li><a href="#system_file_encoding">6.1. System file encoding</a></li>
<li><a href="#environment_variable_tracking">6.2. Environment variable tracking</a></li>
<li><a href="#line_endings">6.3. Line endings</a></li>
<li><a href="#symbolic_links">6.4. Symbolic links</a></li>
<li><a href="#java_version_tracking">6.5. Java version tracking</a></li>
<li><a href="#avoid_changing_inputs_external_to_your_build">6.6. Avoid changing inputs external to your build</a></li>
<li><a href="#suggestions_for_authoring_your_build">6.7. Suggestions for authoring your build</a></li>
<li><a href="#achieving_stable_task_inputs">6.8. Achieving stable task inputs</a></li>
<li><a href="#custom_and_third_party_tasks">6.9. Custom and third party tasks</a></li>
</ul>
</li>
<li><a href="#summary">7. Summary</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The best way to do work faster is to not do work that doesn’t need doing. Gradle has two main mechanisms to avoid work at the task level:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>incremental build</strong> avoids running a task if its inputs and outputs are equivalent to what they were during its previous execution,</p>
</li>
<li>
<p><strong>task output caching</strong> re-uses task outputs produced with the same inputs anytime before, on any machine that is connected to the same build cache backend.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This guide covers the different use cases for Gradle’s build cache, from local-only development to caching task outputs across large teams. We will discuss ways to measure the advantages provided by the build cache, and methods to improve cache performance, or to diagnose and fix common problems. Let’s dive in!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="use_cases_for_the_build_cache"><a class="anchor" href="#use_cases_for_the_build_cache"></a>1. Use cases for the build cache</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gradle’s build cache is a versatile feature that can be used in different ways.</p>
</div>
<div class="sect2">
<h3 id="speed_up_developer_builds_with_the_local_cache"><a class="anchor" href="#speed_up_developer_builds_with_the_local_cache"></a>1.1. Speed up developer builds with the local cache</h3>
<div class="paragraph">
<p>Even when used by a single developer only, the build cache can be pretty useful. Gradle&#8217;s <em>incremental build</em> feature helps avoid work that is already done, but once you change the inputs of a task, it forgets any previous results. When you are switching branches back and forth, the local results get rebuilt over and over again, even if you are building something that has already been built before. The build cache remembers, though, and heavily reduces the need to rebuild things when they were already built locally. In general it&#8217;s very useful when you need to rebuild different commits, like when running <code>git bisect</code>.</p>
</div>
<div class="paragraph">
<p>The local cache can also be useful when working with a project that has multiple variants dimensions, like in the case of Android applications. Each variant has a number of tasks associated with it, and some of those task variants, despite having different names, can end up doing the same things. With the local cache enabled re-use between task variants will happen automatically when applicable.</p>
</div>
</div>
<div class="sect2">
<h3 id="share_results_between_ci_builds"><a class="anchor" href="#share_results_between_ci_builds"></a>1.2. Share results between CI builds</h3>
<div class="paragraph">
<p>The build cache can do more than going back-and-forth in time: it can also bridge physical distance between computers, allowing results generated on one machine to be re-used by another.
A usual first step when introducing the build cache within a team is to enable it for builds running as part of <em>continuous integration</em> only. Using a shared HTTP build cache backend (such as <a href="https://gradle.com/build-cache/">the one provided by Gradle Enterprise</a>) can significantly reduce the work CI agents need to do.
This translates into faster feedback to developers, and less money spent on the CI infrastructure.</p>
</div>
<div class="paragraph">
<p>Using the build cache on CI first makes sense as the environment on CI agents is usually easier to control than developer machines.
It helps to point out possible issues with the build that hurt cacheability.</p>
</div>
<div class="paragraph">
<p>If you are subject to audit requirements regarding the artifacts you ship to your customers you may need to disable the build cache for certain builds.
When using Gradle Enterprise you can easily find out which build produced an artifact coming from the build cache by clicking on the <code>FROM-CACHE</code> status:</p>
</div>
<div class="imageblock screenshot">
<div class="content">
<img src="images/from-cache-origin.png" alt="from cache origin">
</div>
</div>
</div>
<div class="sect2">
<h3 id="accelerate_developer_builds_by_reusing_ci_results"><a class="anchor" href="#accelerate_developer_builds_by_reusing_ci_results"></a>1.3. Accelerate developer builds by reusing CI results</h3>
<div class="paragraph">
<p>When multiple developers work on the same project, they don&#8217;t just need to build their own changes: whenever they pull from version control, they end up having to build each others' changes as well. If the pulled changes are sufficiently independent, the developer can safely re-use outputs already generated on CI. Say, you&#8217;re working on module "A", and you pull in some changes to module "B" (which does not depend on your module). If those changes were already built in CI, you can download the task outputs for module "B" from the cache instead of generating them locally.</p>
</div>
<div class="paragraph">
<p>The changes don&#8217;t need to be completely independent, either; we&#8217;ll take a look at the strategies to re-use results when dependencies are involved in the section about the <a href="#normalization">different forms of normalization</a>.</p>
</div>
<div class="paragraph">
<p>It may be helpful to have your CI builds push to a branch after the build warming up the build cache completed.
In this way every developer can pull from this branch and benefit from using the shared build cache.</p>
</div>
</div>
<div class="sect2">
<h3 id="combine_ci_results_with_local_caching_on_developer_machines"><a class="anchor" href="#combine_ci_results_with_local_caching_on_developer_machines"></a>1.4. Combine CI results with local caching on developer machines</h3>
<div class="paragraph">
<p>Developers can utilize both a local and a remote cache. While pulling results from a CI-filled remote cache helps to avoid work needed because of changes by other developers, the local cache can speed up switching branches and doing <code>git bisect</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="share_results_between_developers"><a class="anchor" href="#share_results_between_developers"></a>1.5. Share results between developers</h3>
<div class="paragraph">
<p>Using the local cache is a sort of one-to-one thing, while the HTTP cache typically has a one-to-many topology. Gradle also allows the use of distributed caches, for example with using the <a href="https://github.com/gradle/gradle-hazelcast-plugin/">Hazelcast cache backend</a>.</p>
</div>
<div class="paragraph">
<p>It is also possible to allow developers to upload their results to a shared cache, thus making them available for everyone else, even before CI had a chance to build them.</p>
</div>
<div class="paragraph">
<p>While sharing results from developer machines seems like a good idea at first sight, it might not always be what you are looking for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The environment on developer machines is usually not as strictly controlled as it is on CI. Gradle tries to track every relevant bit of information that can influence a task&#8217;s output, but if there are tasks that are incorrectly defined, developers can pollute the cache with corrupted results.</p>
</li>
<li>
<p>Gradle is in general safe to be used with incremental builds. However, we recommend only uploading to a shared cache from <code>clean</code> builds.</p>
</li>
<li>
<p>Developers can make changes to task outputs while the task is running even unintentionally, or even unknowingly, like continuing making changes in their IDEs while the build is running. Currently, Gradle has no good way to defend against these changes, and will simply cache whatever is in the output directory once the task is finished. This again can lead to corrupted results being uploaded to the shared cache.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="build_cache_performance"><a class="anchor" href="#build_cache_performance"></a>2. Build cache performance</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The sole reason to use any build cache is to make builds faster. But how much faster can you go when using the cache? Measuring the impact is both important and complicated, as cache performance is determined by many factors. Initial measurements of the cache&#8217;s impact can validate the extra effort (work, infrastructure) that was required to start using the cache. These measurements can later serve as baselines for future improvements, and to watch for signs of regressions.</p>
</div>
<div class="sect2">
<h3 id="fully_cached_builds"><a class="anchor" href="#fully_cached_builds"></a>2.1. Fully cached builds</h3>
<div class="paragraph">
<p>The most straightforward way to get a feel for what the cache can do for you is to measure the difference between a non-cached build and a <em>fully cached</em> build. This will give you the theoretical limit of how fast builds with the cache can get, if everything you&#8217;re trying to build has already been built. The easiest way to measure this is using the local cache:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Clean the cache directory to avoid any hits from previous builds (<code>rm -rf $GRADLE_HOME/caches/build-cache-*</code>)</p>
</li>
<li>
<p>Run the build (e.g. <code>./gradlew --build-cache clean assemble</code>), so that all the results from cacheable tasks get stored in the cache.</p>
</li>
<li>
<p>Run the build again (e.g. <code>./gradlew --build-cache clean assemble</code>); depending on your build, this time you should see many of the tasks being cached.</p>
</li>
<li>
<p>Compare the execution time for the two builds</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You might have encountered a few cached tasks even in the first of the two builds, where no previously cached results should be available.
This can happen if you have tasks in your build that are configured to produce the same results from the same inputs; in such a case once one of these tasks has finished, Gradle will simply re-use its output for the rest of the tasks.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Normally, your <em>fully cached</em> build should be significantly faster than the <code>clean</code> build: this is the theoretical limit of how much time using the build cache can save on your particular build when running the tasks that you were running.
We&#8217;ll be covering several common causes for why your build might not produce amazing numbers here for the first try, see <a href="#finding_problems">Finding problems with task output caching</a>.
Build scans provide a detailed performance breakdown which show you how effectively your build is using the build cache:</p>
</div>
<div class="imageblock screenshot">
<div class="content">
<img src="images/performance-task-execution.png" alt="performance task execution">
</div>
</div>
<div class="paragraph">
<p>In everyday situations fully cached builds are rare, as the purpose of running a build is to process some new changes. The structure of the software being built (how many modules are there, how independent are its parts etc.), and the nature of the changes themselves ("big refactor in the core of the system" vs. "small change to a unit test" etc.) strongly influence the caching performance. As developers tend to submit different kinds of changes over time, caching performance is expected to vary with each change. As with any cache, the impact should thus be measured over time.</p>
</div>
<div class="paragraph">
<p>In a setup where a team uses a shared cache backend, there are two locations worth measuring cache impact at: on CI and on developer machines.</p>
</div>
</div>
<div class="sect2">
<h3 id="cache_impact_on_ci_builds"><a class="anchor" href="#cache_impact_on_ci_builds"></a>2.2. Cache impact on CI builds</h3>
<div class="paragraph">
<p>The best way to learn about the impact of caching on CI is to set up the same builds with the cache enabled and disabled, and compare the results over time. If you have a single Gradle build step that you want to enable caching for, it&#8217;s easy to compare the results using your CI system&#8217;s built-in statistical tools.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sanity-check-graph.png" alt="single build comparison">
</div>
<div class="title">Figure 1. Comparison graph for Gradle&#8217;s sanity check build</div>
</div>
<div class="paragraph">
<p>Measuring complex pipelines requires some more work, and some external tool to collect and process measurements.
It&#8217;s important to distinguish those parts of the pipeline that caching has no effect on, for example the time builds spend waiting in the CI system&#8217;s queue, or time taken by checking out source code from version control.</p>
</div>
<div class="paragraph">
<p>You can use the build statistics if you use Teamcity for your CI builds.
Most of time you will end up extracting data from your CI server via the corresponding REST API (see <a href="https://wiki.jenkins-ci.org/display/JENKINS/Remote+access+API">Jenkins remote access API</a> and <a href="https://confluence.jetbrains.com/display/TCD10/REST+API">Teamcity REST API</a>).
When using Gradle Enterprise, you can use the <a href="https://docs.gradle.com/enterprise/export-api/">export API</a> to access the necessary data and run your analytics on them.</p>
</div>
<div class="paragraph">
<p>Typically, CI builds above a certain size include parallel sections to utilize multiple agents. With parallel pipelines you can measure the wall-clock time it takes for a set of changes to go from having been pushed to version control to being built, verified and deployed. The build cache&#8217;s effect in this case can be measured in the reduction of the time developers have to wait for feedback from CI.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/stage-2-time-to-developer-feedback.png" alt="time to developer feedback">
</div>
<div class="title">Figure 2. Feedback time comparison graph for Gradle&#8217;s stage 2 pipeline, which includes code quality and fast running integration tests</div>
</div>
<div class="paragraph">
<p>You can also measure the cumulative time it took to build a changeset, which will give you a sense of the amount of work the CI infrastructure has to excert. The cache&#8217;s effect here is less money spent on CI infrastructure, as you don&#8217;t need as many CI agents to maintain the same number of changes built.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/stage-2-cumulative-time-graph.png" alt="cumulative build time">
</div>
<div class="title">Figure 3. Cumulative build time comparison graph for Gradle&#8217;s stage 2 pipeline</div>
</div>
</div>
<div class="sect2">
<h3 id="measuring_developer_builds"><a class="anchor" href="#measuring_developer_builds"></a>2.3. Measuring developer builds</h3>
<div class="paragraph">
<p>Gradle&#8217;s build cache can be very useful in reducing CI infrastructure cost and feedback time, but it usually has the biggest impact when developers can re-use cached results in their local builds. This is also the hardest to quantize for a number of reasons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>developers run different builds</p>
</li>
<li>
<p>developers can have different hardware, or have different settings</p>
</li>
<li>
<p>developers run all kinds of other things on their machines that can slow them down</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When using Gradle Enterprise you can use the <a href="https://docs.gradle.com/enterprise/export-api/">export API</a> to extract data about developer builds, too.
You can then create statistics on how many tasks where cached per developer or build.
You can even compare the times it took to execute the task to pulling it from the cache and then estimate the time saved per developer.</p>
</div>
<div class="paragraph">
<p>When using the <a href="https://gradle.com/build-cache">Gradle Enterprise build cache backend</a> you should pay close attention to the hit rate in the admin UI.
A rise in the hit rate there probably indicates better usage by developers:</p>
</div>
<div class="imageblock screenshot">
<div class="content">
<img src="images/cache-admin-hit-rate.png" alt="build cache hit rate">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="important_concepts"><a class="anchor" href="#important_concepts"></a>3. Important concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As we said before, how much of your build gets loaded from cache depends on many factors. In this section we&#8217;ll review some of the tools that are essential for well-cached builds.</p>
</div>
<div class="sect2">
<h3 id="concepts_repeatable_task_outputs"><a class="anchor" href="#concepts_repeatable_task_outputs"></a>3.1. Repeatable task outputs</h3>
<div class="paragraph">
<p>Imagine that you&#8217;ve just pulled the main branch of your software afresh from version control. CI has already built this particular commit, so the remote cache should be hot: if you ran a build now, every cacheable task would be loaded from cache.</p>
</div>
<div class="paragraph">
<p>Consider now making a small change to the inputs of your code generator task. Let&#8217;s make this a change that will not result in any <em>meaningful</em> difference to the code-generator. Maybe add an empty line at the end of a file, or change a comment.</p>
</div>
<div class="paragraph">
<p>Because you&#8217;ve changed its inputs, the code generator task needs to execute again during the next build. However, it will generate <em>exactly the same output</em> as before, so anything that depends on that output will stay up-to-date.</p>
</div>
<div class="paragraph">
<p>On the other hand, your code generator might add some extra information to its output that doesn&#8217;t depend on its declared inputs, like a timestamp. In such a case the otherwise unimportant change to the code generator&#8217;s inputs <em>will</em> result in different code being generated (because the timestamp will be updated). Tasks that depend on the code generator&#8217;s output will need to be re-executed.</p>
</div>
<div class="paragraph">
<p>The key here is not to depend on undeclared volatile inputs like the aforementioned timestamps, or sequences like a CI build number.</p>
</div>
</div>
<div class="sect2">
<h3 id="stable_task_inputs"><a class="anchor" href="#stable_task_inputs"></a>3.2. Stable task inputs</h3>
<div class="paragraph">
<p>Having a task repeatably produce the same output is not enough if its inputs keep changing all the time.
Such unstable inputs can be supplied directly to the task. Think of a version number that includes a timestamp being added to the jar file&#8217;s manifest:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">version = <span class="string"><span class="delimiter">&quot;</span><span class="content">3.2-</span><span class="inline"><span class="inline-delimiter">${</span><span class="predefined-type">System</span>.currentTimeMillis()<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>

jar {
    manifest {
        attributes(<span class="string"><span class="delimiter">&quot;</span><span class="content">Implementation-Version</span><span class="delimiter">&quot;</span></span>: version)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another example for unstable inputs is the commit ID from version control.
Maybe your version number is generated via <code>git describe</code> (and you include it in the jar manifest as shown above).
Or maybe you include the commit hash directly in <code>version.properties</code> or a JAR manifest attribute.
Either way, the outputs produced by any tasks depending on such data will only be re-usable by builds running against the exact same commit.</p>
</div>
<div class="paragraph">
<p>Tasks are rarely work in a standalone fashion, and instead frequently depend on each other&#8217;s outputs.
A task using the non-repeatable outputs of another task as its inputs is a frequent way to introduce unstable inputs, too.</p>
</div>
</div>
<div class="sect2">
<h3 id="normalization"><a class="anchor" href="#normalization"></a>3.3. Better re-use via input normalization</h3>
<div class="paragraph">
<p>We saw that having stable inputs is crucial for cacheable tasks.
However, achieving byte by byte identical inputs for each task can be challenging.
In some cases sanitizing the output of a task to remove unnecessary information can be a good approach, but this also means that a task&#8217;s output can only be normalized for a single purpose.</p>
</div>
<div class="paragraph">
<p>This is where <a href="https://docs.gradle.org/4.0-rc-2/userguide/more_about_tasks.html#sec:configure_input_normalization">input normalization</a> comes into play.
Input normalization is used by Gradle to determine if two task inputs are <em>essentially</em> the same.
Gradle uses normalized inputs when doing up-to-date checks and when determining if a cached result can be re-used instead of executing the task.
As input normalization is declared by the task <em>consuming</em> the data as input, different tasks can define different ways to normalize the same data.</p>
</div>
<div class="paragraph">
<p>When it comes to file inputs, Gradle can normalize the path of the files as well as their contents.</p>
</div>
<div class="sect3">
<h4 id="relocatability"><a class="anchor" href="#relocatability"></a>3.3.1. Path sensitivity and relocatability</h4>
<div class="paragraph">
<p>When sharing cached results between computers, it&#8217;s rare that everyone runs the build from the exact same location on their computers.
To allow cached results to be shared even when builds are executed from different root directories, Gradle needs to understand which inputs can be relocated and which cannot.</p>
</div>
<div class="paragraph">
<p>Tasks having files as inputs can declare the parts of a file&#8217;s path what are essential to them: this is called the <em>path sensitivity</em> of the input.
Task properties declared with <code>ABSOLUTE</code> path sensitivity are considered non-relocatable.
This is the default for properties not declaring path sensitivity, too.</p>
</div>
<div class="paragraph">
<p>For example, the class files produced by the Java compiler are dependent on the file names of the Java source files: renaming the source files with public classes would fail the build.
However, moving the files around would have no effect on the result of the compilation.
Therefore, the path sensitivity for the sources of the <code>JavaCompile</code> task is <code>NAME_ONLY</code>. Because of this only the normalized paths of the Java source files&#8201;&#8212;&#8201;the file names&#8201;&#8212;&#8201;are considered as inputs to the <code>JavaCompile</code> task.</p>
</div>
</div>
<div class="sect3">
<h4 id="content_normalization"><a class="anchor" href="#content_normalization"></a>3.3.2. Content normalization</h4>
<div class="sect4">
<h5 id="compile_avoidance"><a class="anchor" href="#compile_avoidance"></a>Compile avoidance for Java</h5>
<div class="paragraph">
<p>When it comes to the dependencies of a <code>JavaCompile</code> task (i.e. its <em>compile classpath),</em> only changes to the Application Binary Interface (ABI) of these dependencies require compilation to be executed.
Gradle has a deep understanding of what a compile classpath is and uses a sophisticated normalization strategy for it.
Task outputs can be re-used as long the the ABI of the classes on the compile classpath stays the same.
This enables Gradle to avoid Java compilation by using incremental builds, or load results from the cache that were produced by different (but ABI-compatible) versions of dependencies.
For more information on compile avoidance see the corresponding section in the <a href="https://docs.gradle.org/4.0-rc-2/userguide/java_plugin.html#sec:java_compile_avoidance">user guide</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="runtime_classpath"><a class="anchor" href="#runtime_classpath"></a>Runtime classpath normalization</h5>
<div class="paragraph">
<p>Similar to compile avoidance, Gradle does understand the concept of a runtime classpath, and uses tailored input normalization to avoid running e.g. tests.
For runtime classpaths Gradle inspects the contents of jar files and ignores the timestamps and order of the entries in the jar file.
This means that a rebuilt jar file would be considered the same runtime classpath input.
For details on what level of understanding Gradle has for detecting changes to classpaths see the <a href="https://docs.gradle.org/4.0-rc-2/userguide/more_about_tasks.html#sec:task_input_using_classpath_annotations">userguide</a>.</p>
</div>
<div class="sect5">
<h6 id="filter_runtime_classpath"><a class="anchor" href="#filter_runtime_classpath"></a>Filtering runtime classpaths</h6>
<div class="paragraph">
<p>For a runtime classpath it is possible to provide better insights to Gradle which files are essential to the input by <a href="https://docs.gradle.org/4.0-rc-2/userguide/more_about_tasks.html#sec:configure_input_normalization">configuring input normalization</a>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say you want to add a file <code>build-info.properties</code> to all your produced jar files which contains volatile information about the build, e.g. the timestamp when the build started or some ID to identify the CI job that published the artifact.
This file is only used for auditing purposes, and has no effect on the outcome of running tests.
Nonetheless, this file is part of the runtime classpath for the <code>test</code> task. Since the file changes on every build invocation, tests cannot be cached effectively.
To fix this you can ignore <code>build-info.properties</code> on any runtime classpath by adding the following configuration to build script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">normalization {
    runtimeClasspath {
        ignore <span class="string"><span class="delimiter">&quot;</span><span class="content">build-info.properties</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The effect of this configuration would be that changes to <code>build-info.properties</code> would be ignored for both up-to-date checks and task output caching.
This will not change the runtime behavior of the <code>test</code> task&#8201;&#8212;&#8201;i.e. any test is still able to load <code>build-info.properties</code>, and the runtime classpath stays the same as before.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="concepts_overlapping_outputs"><a class="anchor" href="#concepts_overlapping_outputs"></a>3.4. The case against overlapping outputs</h3>
<div class="paragraph">
<p>When two tasks write to the same output directory or output file, it is difficult for Gradle to determine which output belongs to which task.
There are many edge cases, and executing the tasks in parallel cannot be done safely.
It is also hard to automatically remove stale output files for the same reason.
Tasks that have dedicated, non-overlapping outputs can always be handled in a safe fashion by Gradle.
For the aforementioned reasons, task output caching is automatically disabled for tasks whose output directories overlap with another task.
Removing any overlapping outputs is important for good caching performance.</p>
</div>
<div class="paragraph">
<p>Gradle Enterprise will show tasks where caching was disabled for overlapping outputs in the timeline:</p>
</div>
<div class="imageblock screenshot">
<div class="content">
<img src="images/overlapping-outputs-timeline.png" alt="overlapping outputs timeline">
</div>
</div>
</div>
<div class="sect2">
<h3 id="re_use_of_outputs_between_different_tasks"><a class="anchor" href="#re_use_of_outputs_between_different_tasks"></a>3.5. Re-use of outputs between different tasks</h3>
<div class="paragraph">
<p>Some builds exhibit a surprising characteristic: even when executed against an empty cache, they produce tasks loaded from cache. How is this possible? Rest assured that this is completely normal.</p>
</div>
<div class="paragraph">
<p>When considering task outputs, Gradle only cares about the inputs to the task: the task type itself, input files and parameters etc., but it doesn&#8217;t care about the task&#8217;s name or which project it can be found in.
Running <code>javac</code> will produce the same output regardless of the name of the <code>JavaCompile</code> task that invoked it.
If your build includes two tasks that share every input, the one executing later will be able to re-use the output produced by the first.</p>
</div>
<div class="paragraph">
<p>Having two tasks in the same build that do the same might sound like a problem to fix, but it is not necessarily something bad.
For example, the Android plugin creates several tasks for each variant of the project; some of those tasks will potentially do the same thing.
These tasks can safely re-use each other&#8217;s outputs.</p>
</div>
</div>
<div class="sect2">
<h3 id="non_cacheable_tasks"><a class="anchor" href="#non_cacheable_tasks"></a>3.6. Non-cacheable tasks</h3>
<div class="paragraph">
<p>We&#8217;ve been talking quite a bit about cacheable tasks, which implies there are non-cacheable ones, too. If caching task outputs is as awesome as it sounds, why not cache every task?</p>
</div>
<div class="paragraph">
<p>There are tasks that are definitely worth caching: tasks that do complex, repeatable processing and produce moderate amounts of output. Compilation tasks are usually ideal candidates for caching. At the other end of the spectrum lie I/O-heavy tasks, like <code>Copy</code> and <code>Sync</code>. Moving files around locally typically cannot be sped up by copying them from a cache. If we did so, we would even waste good resources on storing all those redundant results in the cache.</p>
</div>
<div class="paragraph">
<p>Most tasks are either obviously worth caching, or obviously not. For those in-between a good rule of thumb is to see if downloading results would be significantly faster than producing them locally.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="caching_java_projects"><a class="anchor" href="#caching_java_projects"></a>4. Caching Java projects</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As of Gradle 4.0, the build tool fully supports caching plain Java projects.
Built-in tasks for compiling, testing, documenting and checking the quality of Java code are cached by default.</p>
</div>
<div class="sect2">
<h3 id="java_compilation"><a class="anchor" href="#java_compilation"></a>4.1. Java compilation</h3>
<div class="paragraph">
<p>Caching Java compilation makes use of Gradle&#8217;s deep understanding of compile classpaths.
The mechanism <a href="#compile_avoidance">avoids recompilation</a> when dependencies change in a way that doesn&#8217;t affect their abstract binary interfaces (ABI).
Since the cache key is only influenced by the ABI of dependencies (and not by their implementation details like private types and method bodies), task output caching can also re-use compiled classes if they were produced by the same sources and ABI-equivalent dependencies.</p>
</div>
<div class="paragraph">
<p>For example, take a project with two modules: an application depending on a library.
Suppose the latest version is already built by CI and uploaded to the shared cache.
If a developer now modifies a method&#8217;s body in the library, the library will need to be rebuilt on their computer. But they will be able to pull the compiled classes for the application from the shared cache. Gradle can do this because the library used to compile the application on CI, and the modified library available locally share the same ABI.</p>
</div>
<div class="sect3">
<h4 id="annotation_processors"><a class="anchor" href="#annotation_processors"></a>4.1.1. Annotation processors</h4>
<div class="paragraph">
<p>You do not have to do anything to make this work.
There is one caveat though: when using annotation processors, Gradle uses the annotation processor classpath as an input.
As this is a runtime classpath, less <a href="#runtime_classpath">input normalization</a> is taking place there.
When the annotation processor classpath is not set explicitly, it defaults to the compile classpath, which in turn means the compile classpath is treated as a runtime classpath input.</p>
</div>
<div class="paragraph">
<p>For the example above this would mean the ABI extracted from the compile classpath would be unchanged, but the annotation processor classpath (because it&#8217;s not treated with compile avoidance) would be different. Ultimately, the developer would end up having to recompile the application.</p>
</div>
<div class="paragraph">
<p>The easiest way to avoid this performance penalty is to not use annotation processors. If you need to use them, make sure you set the annotation processor classpath explicitly to include only the libraries needed for annotation processing. The <a href="https://docs.gradle.org/4.0-rc-2/userguide/java_plugin.html#sec:java_compile_avoidance">user guide</a> describes how to do this.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unit_test_execution"><a class="anchor" href="#unit_test_execution"></a>4.2. Unit test execution</h3>
<div class="paragraph">
<p>The <code>Test</code> task used for test execution for JVM languages employs <a href="#runtime_classpath">runtime classpath normalization</a> for its classpath.
This means that changes to order and timestamps in jars on the test classpath will not cause the task to be out-of-date or change the build cache key.
For achieving <a href="#stable_task_inputs">Stable task inputs</a> you also can wield the power of <a href="#filter_runtime_classpath">filtering the runtime classpath</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="integration_test_execution"><a class="anchor" href="#integration_test_execution"></a>4.3. Integration test execution</h3>
<div class="paragraph">
<p>Unit tests are easy to cache as they normally have no external dependencies.
For integration tests the situation can be quite different, as they can depend on a variety of inputs outside of the test and production code.
These external factors can be for example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>operating system type and version,</p>
</li>
<li>
<p>external tools being installed for the tests,</p>
</li>
<li>
<p>environment variables and Java system properties,</p>
</li>
<li>
<p>other services being up and running,</p>
</li>
<li>
<p>a distribution of the software under test.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You need to be careful to declare these additional inputs for your integration test in order to avoid incorrect cache hits.
For example, declaring the operating system in use by Gradle as an input to a <code>Test</code> task called <code>integTest</code> would work as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">integTest {
    inputs.property(<span class="string"><span class="delimiter">&quot;</span><span class="content">operatingSystem</span><span class="delimiter">&quot;</span></span>) {
        <span class="predefined-type">System</span>.getProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">os.name</span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="archives_as_inputs"><a class="anchor" href="#archives_as_inputs"></a>4.3.1. Archives as inputs</h4>
<div class="paragraph">
<p>Depending on a zip or tar archive as an input file will lead to cache misses since rebuilding will probably change the metadata in the archive as described in <a href="#concepts_repeatable_task_outputs">Repeatable task outputs</a>.
To avoid this problem altogether you can instead depend on the contents on the archive. See also the section on dealing with <a href="#volatile_outputs">non-repeatable outputs</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="dealing_with_file_paths"><a class="anchor" href="#dealing_with_file_paths"></a>4.3.2. Dealing with file paths</h4>
<div class="paragraph">
<p>You will probably pass some information from the build environment to your integration test tasks by using system properties.
When passing file locations, use only relative paths whenever possible, and add the input file as an input manually, so that Gradle can track changes to the contents of the file.
(This works with directories as well.)
Passing absolute paths will break <a href="#relocatability">relocatability</a> of the integration test task.
For example, with a task called <code>integTest</code>, instead of this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">integTest {
    systemProperty <span class="string"><span class="delimiter">&quot;</span><span class="content">distribution.location</span><span class="delimiter">&quot;</span></span>, file(<span class="string"><span class="delimiter">&quot;</span><span class="content">build/dist</span><span class="delimiter">&quot;</span></span>).absolutePath
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;it is better to do this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">integTest {
    systemProperty <span class="string"><span class="delimiter">&quot;</span><span class="content">distribution.location</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">build/dist</span><span class="delimiter">&quot;</span></span> <i class="conum" data-value="1"></i><b>(1)</b>
    inputs.dir(<span class="string"><span class="delimiter">&quot;</span><span class="content">build/dist</span><span class="delimiter">&quot;</span></span>).withPropertyName(<span class="string"><span class="delimiter">&quot;</span><span class="content">distDir</span><span class="delimiter">&quot;</span></span>).withPathSensitivity(PathSensitivity.RELATIVE) <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Adding the relative path as system property.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Adding all the files under the distribution directory as an input.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="ignoring_system_properties"><a class="anchor" href="#ignoring_system_properties"></a>4.3.3. Ignoring system properties</h4>
<div class="paragraph">
<p>It may be necessary to ignore some system properties as inputs as they do not influence the outcome of the integration tests.
This is possible by overriding the <code>systemProperties</code> input property via the runtime API.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">integTest {
    <span class="keyword">def</span> ciProperties = [<span class="key">agentNumber</span>: (<span class="predefined-type">System</span>.getenv().get(<span class="string"><span class="delimiter">&quot;</span><span class="content">AGENT_NUMBER</span><span class="delimiter">&quot;</span></span>) ?: <span class="integer">1</span>] <i class="conum" data-value="1"></i><b>(1)</b>
    systemProperties(ciProperties) <i class="conum" data-value="2"></i><b>(2)</b>

    inputs.property(<span class="string"><span class="delimiter">'</span><span class="content">systemProperties</span><span class="delimiter">'</span></span>) { <i class="conum" data-value="3"></i><b>(3)</b>
        systemProperties - ciProperties <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This property does not influence the output of the integration tests.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Set the system properties for the actual test execution.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Overwrite the <code>systemProperties</code> input property.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The new value for the <code>systemProperties</code> input without the ignored property.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="caching_code_buildsrc_code"><a class="anchor" href="#caching_code_buildsrc_code"></a>4.4. Caching <code>buildSrc</code></h3>
<div class="paragraph">
<p>The <a href="https://docs.gradle.org/4.0-rc-2/userguide/organizing_build_logic.html#sec:build_sources"><code>buildSrc</code> project</a> can be used to organize build logic in your Gradle build.
While <code>buildSrc</code> typically does not change frequently, when it does every developer and CI agent needs to re-build and test it.
Therefore, it is usually desirable to use task output caching for <code>buildSrc</code>, too.
To use the same build cache configuration for <code>buildSrc</code> as for your root project, you can apply the same script both in <code>buildSrc/settings.gradle</code> and in <code>settings.gradle</code> as shown in the <a href="https://docs.gradle.org/4.0-rc-2/userguide/build_cache.html#buildCacheBuildSrc">user guide</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="debugging_and_diagnosing_cache_misses"><a class="anchor" href="#debugging_and_diagnosing_cache_misses"></a>5. Debugging and diagnosing cache misses</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For using task output caching efficiently it is essential to keep the balance between specifying all the inputs to your
tasks while not over-specifying them. If you don&#8217;t specify enough of your inputs then your build will be incorrect and you
will share outputs between tasks that should have had a different output. If you specify unnecessary inputs to your tasks,
 you will have cache misses while you could have re-used earlier outputs.
 For Gradle&#8217;s built-in tasks we prefer to err on the side of correctness and we suggest that you do the same.</p>
</div>
<div class="paragraph">
<p>This chapter is about finding out why a cache miss was happening. If you have a cache hit which you didn&#8217;t expect we
suggest to declare whatever change you expected to trigger the cache miss as an input to the task.</p>
</div>
<div class="sect2">
<h3 id="finding_problems"><a class="anchor" href="#finding_problems"></a>5.1. Finding problems with task output caching</h3>
<div class="paragraph">
<p>In order to find existing problems with your usage of task output caching you can do a variety of things.</p>
</div>
<div class="paragraph">
<p>First, you should start out with running a fully up-to-date build.
You do not even have to enable the build cache for this exercise.
The expected outcome is that that all incremental tasks are up-to-date.
Tasks which have no output or no inputs will always be executed, but that shouldn&#8217;t be a problem.
If you find some tasks which are out of date then use the methods from <a href="#diagnosing_cache_miss">Diagnosing the reasons for a cache miss</a> to determine the changed inputs for the tasks and use the methods from <a href="#common-problems">Solving common problems</a> to fix those tasks.
The goal is to achieve <a href="#stable_task_inputs">Stable task inputs</a> for cacheable tasks.
If you find a task which is out of date but no cacheable tasks depend on its outcome then you don&#8217;t have to do anything about it.</p>
</div>
<div class="paragraph">
<p>When you are happy with the up-to-date performance then you can repeat the experiment above but this time with a clean build and the build cache turned on.
The goal with clean builds and the build cache turned on is to retrieve all cacheable tasks from the cache.
You should start out simple and use the same checkout for the consumer build.
When you are happy with the performance in the single workspace use-case you can go further:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use different workspaces on the same machine.</p>
</li>
<li>
<p>Use different workspaces on different machines using a remote build cache.</p>
</li>
<li>
<p>Use the cache populated by a CI build and a developer machine.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>After these experiments with fully cache builds you can go on and try to make typical changes to your project and see if enough tasks are still cached.
If the results are not satisfactory you should think about restructuring your project to reduce dependencies between different tasks.</p>
</div>
<div class="paragraph">
<p>We had good experiences with recording execution times of our builds, generate graphs of those and then look at the results.
You then can look for certain patterns, like a rebuilding everything even though you expected compilation to be cached.</p>
</div>
<div class="paragraph">
<p>You can also make certain changes to your code base manually or automatically and check that the expected set of tasks is cached.</p>
</div>
<div class="paragraph">
<p>If these experiments point to a possible problem with your use of task output caching, you would need to go into diagnosing a cache miss as explained below.</p>
</div>
</div>
<div class="sect2">
<h3 id="helpful_data_for_diagnosing_a_cache_miss"><a class="anchor" href="#helpful_data_for_diagnosing_a_cache_miss"></a>5.2. Helpful data for diagnosing a cache miss</h3>
<div class="paragraph">
<p>A cache miss happens when Gradle calculates a build cache key for a task which is different from any of the build cache keys in the cache.
Only comparing the build cache key on its own does not give much information, so we need to look at some finer grained data to be able to diagnose the cache miss.
All the things influencing the build cache key can be found in the <a href="https://docs.gradle.org/4.0-rc-2/userguide/build_cache.html#sec:task_output_caching_details">userguide</a>.</p>
</div>
<div class="paragraph">
<p>Basically, we can compare the following data, listed from coarse grained to fine grained:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Build cache keys</p>
</li>
<li>
<p>Task and Task action implementations</p>
<div class="ulist">
<ul>
<li>
<p>classloader hash</p>
</li>
<li>
<p>class name</p>
</li>
</ul>
</div>
</li>
<li>
<p>Task output property names</p>
</li>
<li>
<p>Individual task property input hashes</p>
</li>
<li>
<p>Hashes of files which are part of task input properties</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Currently, the build cache key for the task is logged at the info level,
while information down to the individual input property level is available in the info log:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Appending taskClass to build cache key: org.gradle.api.tasks.compile.JavaCompile_Decorated
Appending classLoaderHash to build cache key: da6eca52100422099189290bf68f200a
Appending actionType to build cache key: org.gradle.api.internal.project.taskfactory.AbstractOutputPropertyAnnotationHandler$2$1
Appending actionClassLoaderHash to build cache key: 2cdf3f9202925b5befa161030ab43724
Appending actionType to build cache key: org.gradle.api.internal.project.taskfactory.TaskClassValidator
.
.
.
Appending inputPropertyHash for 'classpath' to build cache key: 2b6ab53aa11d4a7d4a1f95a8f78f4d7c
Appending inputPropertyHash for 'effectiveAnnotationProcessorPath' to build cache key: d41d8cd98f00b204e9800998ecf8427e
Appending inputPropertyHash for 'options.sourcepath' to build cache key: d41d8cd98f00b204e9800998ecf8427e
Appending inputPropertyHash for 'source' to build cache key: f6ba49b2466f0090272c43ac5f54ec1d
Appending outputPropertyName to build cache key: destinationDir
Build cache key for task ':compileJava' is 2b220117efa6710f7ab191a0bbe48c00</pre>
</div>
</div>
<div class="paragraph">
<p>If you want to go into the details of finding out e.g. which classes and jar files constitute the <code>classpath</code> for the <code>compileJava</code>
task you need to resort to comparing those files on disk yourself.</p>
</div>
<div class="paragraph">
<p>Luckily, you do not have to capture this data yourself - the build scan plugin already takes care of this for you.
This means that Gradle Enterprise already has the necessary data to diagnose the cache miss when using the build scan plugin:</p>
</div>
<div class="imageblock screenshot">
<div class="content">
<img src="images/task-inputs-comparison.png" alt="task inputs comparison">
</div>
</div>
<div class="paragraph">
<p>It is also possible that task output caching for a cacheable task was disabled.
When this happens the reason why caching was disabled for the task is reported on the info log level and in the build scan:</p>
</div>
<div class="imageblock screenshot">
<div class="content">
<img src="images/caching-disabled.png" alt="caching disabled">
</div>
</div>
</div>
<div class="sect2">
<h3 id="diagnosing_cache_miss"><a class="anchor" href="#diagnosing_cache_miss"></a>5.3. Diagnosing the reasons for a cache miss</h3>
<div class="paragraph">
<p>Having the data from the last section at hand, you should be able to diagnose why the outputs of a certain task were not found in the build cache.
Since you were expecting more tasks to be cached, you should be able to pinpoint a build which would have produced the artifact under question.</p>
</div>
<div class="paragraph">
<p>Before diving into how to find out why one task has not been loaded from the cache we should first look into which task caused the cache misses.
There is a cascade effect causing dependent tasks to be executed if one of the tasks earlier in the build is not loaded from the cache and has different outputs.
Therefore, you should therefore at the first cacheable task which was executed and continue investigating there.
This can be done from the timeline view in a build scan or from the task input comparison directly:</p>
</div>
<div class="imageblock screenshot">
<div class="content">
<img src="images/first-non-cached-task.png" alt="first non cached task">
</div>
</div>
<div class="paragraph">
<p>At first, you should check if the implementation of the task changed. This would mean checking the class names and classloader hashes
for the task class itself and for each of its action. If there is a change, this means that the build script, <code>buildSrc</code> or the Gradle version has changed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A change in the output of <code>buildSrc</code> also marks all the logic added by your build as changed.
Especially, custom actions added to cacheable tasks will be marked as changed.
This can be problematic, see <a href="#custom_actions">Review usages of <code>doFirst</code> and <code>doLast</code></a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the implementation is the same, then you need to start comparing inputs between the two builds.
There should be at least one different input hash. If it is a simple value property, then the configuration of the task changed.
This can happen for example by</p>
</div>
<div class="ulist">
<ul>
<li>
<p>changing the build script,</p>
</li>
<li>
<p>conditionally configuring the task differently for CI or the developer builds,</p>
</li>
<li>
<p>depending on a system property or an environment variable for the task configuration,</p>
</li>
<li>
<p>or having an absolute path which is part of the input.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the changed property is a file property, then the reasons can be the same as for the change of a value property.
Most probably though a file on the filesystem changed in a way that Gradle detects a difference for this input.
The most common case will be that the source code was changed by a check in.
It is also possible that a file generated by a task changed, e.g. since it includes a timestamp.
As described in <a href="#java_version_tracking">Java version tracking</a>, the Java version can also influence the output of the Java compiler.
If you did not expect the file to be an input to the task, then it is possible that you should alter the configuration of the task to not include it.
For example, having your integration test configuration including all the unit test classes as a dependency has the effect that all integration tests
are re-executed when a unit test changes.
Another option is that the task tracks absolute paths instead of relative paths and the location of the project directory changed on disk.</p>
</div>
</div>
<div class="sect2">
<h3 id="example"><a class="anchor" href="#example"></a>5.4. Example</h3>
<div class="paragraph">
<p>We will walk you through the process of diagnosing a cache miss.
Let&#8217;s say we have build <code>A</code> and build <code>B</code> and we expected all the test tasks for a sub-project <code>sub1</code> to be cached in build <code>B</code> since only a unit test for another sub-project <code>sub2</code> changed.
Actually, all the tests for the sub-project have been executed.
Since we have the cascading effect when we have cache misses, we need to find the task which caused the caching chain to fail.
This can easily be done by filtering for all cacheable tasks which have been executed and then select the first one.
In our case, it turns out that the tests for the sub-project <code>internal-testing</code> were executed even though there was no code change to this project.
We start the input property comparison in Gradle Enterprise and see that the property <code>classpath</code> changed. This means that some file on the runtime classpath actually did change.
Looking deeper into this, we actually see that the inputs for the task <code>processResources</code> changed in that project, too.
Finally, we find this in our build file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task currentVersionInfo() {
    doLast {
        <span class="keyword">def</span> properties = <span class="keyword">new</span> <span class="predefined-type">Properties</span>()
        properties.latestMilestone = version
        properties.store(<span class="keyword">new</span> <span class="predefined-type">File</span>(generatedResourcesDir, <span class="string"><span class="delimiter">&quot;</span><span class="content">currentVersion.properties</span><span class="delimiter">&quot;</span></span>))
    }
}

sourceSets.main.output.dir generatedResourcesDir, <span class="key">builtBy</span>: currentVersionInfo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since properties files stored by Java&#8217;s <code>Properties.store</code> method contain a timestamp, this will cause a change to the runtime classpath every time the build runs.
In order to solve this problem see <a href="#volatile_outputs">Non-repeatable task outputs</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The compile classpath is not affected since compile avoidance ignores non-class files on the compile classpath.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="common-problems"><a class="anchor" href="#common-problems"></a>6. Solving common problems</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Small problems in a build, like forgetting to declare a configuration file as an input to your task, can be easily overlooked. The configuration file might change infrequently, or only change when some other (correctly tracked) input changes as well. The worst that could happen is that your task doesn&#8217;t execute when it should be. Developers can always re-run the build with <code>clean</code>, and "fix" their builds for the price of a slow rebuild. In the end nobody gets blocked in their work, and the incident is chalked up to "Gradle acting up again."</p>
</div>
<div class="paragraph">
<p>With cacheable tasks incorrect results are stored permanently, and can come back to haunt you later; re-running with <code>clean</code> won&#8217;t achieve much either. When using a shared cache, these problems even cross machine boundaries. In the example above, Gradle might end up loading a result for your task that was produced with a different configuration. Resolving these problems with the build thus becomes even more important when task output caching is enabled.</p>
</div>
<div class="paragraph">
<p>Other issues with the build won&#8217;t cause it to produce incorrect results, but will lead to unnecessary cache misses. In this chapter we&#8217;ve compiled a list of some typical problems and ways to avoid them. Fixing these issues will have the side benefit that your build will stop "acting up," and developers can forget about running builds with <code>clean</code> altogether.</p>
</div>
<div class="sect2">
<h3 id="system_file_encoding"><a class="anchor" href="#system_file_encoding"></a>6.1. System file encoding</h3>
<div class="paragraph">
<p>Most Java tools use the system file encoding when no specific encoding is specified.
This means that running the same build on machines with different file encoding can yield different outputs.
Currently Gradle only tracks on a per-task basis that no file encoding has been specified, but it does not track the system encoding of the JVM in use.
This can cause incorrect builds. You should always set the file system encoding to avoid these kind of problems.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Build scripts are compiled with the file encoding of the Gradle daemon.
By default, the daemon uses the system file encoding, too.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Setting the file encoding for the Gradle daemon mitigates both above problems by making sure that the encoding is the same across builds.
You can do so in your <code>gradle.properties</code>:</p>
</div>
<div class="listingblock">
<div class="title">gradle.properties</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="properties">org.gradle.jvmargs=-Dfile.encoding=UTF-8</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="environment_variable_tracking"><a class="anchor" href="#environment_variable_tracking"></a>6.2. Environment variable tracking</h3>
<div class="paragraph">
<p>Gradle does not track changes in environment variables for tasks.
For example for the <code>Test</code> tasks it is completely possible that the outcome depends on a few environment variables.
To ensure that only the right artifacts are re-used between builds, you need to add environment variables as inputs to tasks depending on them.</p>
</div>
<div class="paragraph">
<p>Absolute paths are often passed as environment variables, too. You need to pay attention what you add as an input to the task in this case.
In this case you need to pay special attention to what you add as task inputs.
You would need to ensure that the absolute path is the same between machines. Most times it makes sense to track the file or the contents of the directory the absolute path points to.
If the absolute path represents a tool being used it probably makes sense to track the tool version as an input instead.</p>
</div>
<div class="paragraph">
<p>For example, if you are using tools in your <code>Test</code> task called <code>integTest</code> which depend on the the contents of the <code>LANG</code> variable you should do this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">integTest {
    inputs.property(<span class="string"><span class="delimiter">&quot;</span><span class="content">langEnvironment</span><span class="delimiter">&quot;</span></span>) {
        <span class="predefined-type">System</span>.getenv(<span class="string"><span class="delimiter">&quot;</span><span class="content">LANG</span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you add conditional logic to distinguish CI builds from local development builds, you have to ensure that this does not break the loading of task outputs from CI onto developer machines.
For example, the following setup would break caching of <code>Test</code> tasks, since Gradle always detects the differences in custom task actions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">if</span> (<span class="predefined-type">System</span>.getenv().containsKey(<span class="string"><span class="delimiter">&quot;</span><span class="content">CI</span><span class="delimiter">&quot;</span></span>) {
    test.doFirst {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Running test on CI</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should always add the action unconditionally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">test.doFirst {
    <span class="keyword">if</span> (<span class="predefined-type">System</span>.getenv().containsKey(<span class="string"><span class="delimiter">&quot;</span><span class="content">CI</span><span class="delimiter">&quot;</span></span>) {
            println <span class="string"><span class="delimiter">&quot;</span><span class="content">Running test on CI</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This way, the task has the same custom action on CI and on developer builds and its outputs can be re-used if the remaining inputs are the same.</p>
</div>
</div>
<div class="sect2">
<h3 id="line_endings"><a class="anchor" href="#line_endings"></a>6.3. Line endings</h3>
<div class="paragraph">
<p>If you are building on different operating systems be aware that some version control systems convert line endings on check-out.
For example, Git on Windows uses <code>autocrlf=true</code> by default which converts all line endings to <code>\r\n</code>.
As a consequence, compilation outputs can&#8217;t be re-used on Windows since the input sources are different.
If sharing the build cache across multiple operating systems is important in your environment, then setting <code>autocrlf=false</code> across your build machines is crucial for optimal build cache usage.</p>
</div>
</div>
<div class="sect2">
<h3 id="symbolic_links"><a class="anchor" href="#symbolic_links"></a>6.4. Symbolic links</h3>
<div class="paragraph">
<p>Gradle does not store the symbolic link in the build cache but the actual file contents of the destination of the link.
As a consequence you might have a hard time when trying to re-use outputs which heavily use symbolic links.
There currently is no workaround for this behavior.</p>
</div>
</div>
<div class="sect2">
<h3 id="java_version_tracking"><a class="anchor" href="#java_version_tracking"></a>6.5. Java version tracking</h3>
<div class="paragraph">
<p>Gradle does track the major version of Java as an input for compilation and test execution.
Currently, it does neither track the vendor nor the minor version.
Still, the vendor and the minor version may influence the bytecode produced by compilation.</p>
</div>
<div class="paragraph">
<p>If you use different JVM vendors for compiling or running Java we strongly suggest that you add the vendor as an input to the corresponding tasks.
This can be achieved by using the <a href="https://docs.gradle.org/4.0-rc-2/userguide/more_about_tasks.html#sec:task_input_output_runtime_api">runtime API</a> as shown in the following snippet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">tasks.withType(AbstractCompile) {
    inputs.property(<span class="string"><span class="delimiter">&quot;</span><span class="content">java.vendor</span><span class="delimiter">&quot;</span></span>) {
        <span class="predefined-type">System</span>.getProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">java.vendor</span><span class="delimiter">&quot;</span></span>)
    }
}

tasks.withType(Test) {
    inputs.property(<span class="string"><span class="delimiter">&quot;</span><span class="content">java.vendor</span><span class="delimiter">&quot;</span></span>) {
        <span class="predefined-type">System</span>.getProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">java.vendor</span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With respect to tracking the Java minor version there are different competing aspects: support pulling results for developers and having "perfect" results on CI. There are basically two situations when you may want to track the minor version of Java: for compilation and for runtime.</p>
</div>
<div class="paragraph">
<p>For compilation we saw sometimes differences in the produced bytecode for different minor versions. The bytecode should still expose the same runtime behavior.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://docs.gradle.org/4.0-rc-2/userguide/java_plugin.html#sec:java_compile_avoidance">Java compile avoidance</a> will treat this bytecode the same since it extracts the ABI.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Treating the minor number always as an input would it make very hard for developers to pull from the build cache. We saw that even in bigger companies different developers on the same team were using different Java minor versions. If you are able to control the environment in a way that everybody in your team and on CI is using exactly the same Java minor version then we suggest that you add the minor version as an input.</p>
</div>
<div class="paragraph">
<p>Even without tracking the Java minor version you may have cache misses for developers due to some locally compiled class files which constitute an input to test execution.
If these outputs made it into the local build cache on this developers machine even a clean will not solve the situation.
Therefore, the choice for tracking the Java minor version is between sometimes or never re-using outputs between different Java minor versions for test execution.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The compiler infrastructure provided by the JVM used to run Gradle is also used by the Groovy compiler.
Therefore, you can expect differences in the bytecode of compiled Groovy classes for the same reasons as above and the same suggestions apply.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="avoid_changing_inputs_external_to_your_build"><a class="anchor" href="#avoid_changing_inputs_external_to_your_build"></a>6.6. Avoid changing inputs external to your build</h3>
<div class="paragraph">
<p>If your build is dependent on external dependencies like binary artifacts or dynamic data from a web page you need to make sure that these inputs are consistent throughout your infrastructure.
When there are some variations between machines then there will be no cache hits.</p>
</div>
<div class="paragraph">
<p>Never re-release a non-changing binary dependency with the same version number but different contents: if this happens with a plugin dependency, you will never be able to explain why you don’t see cache re-use between machines (it’s because they have different versions of that artifact).</p>
</div>
<div class="paragraph">
<p>Using <code>SNAPSHOT</code>s or other changing dependencies in your build by design violates the <a href="#stable_task_inputs">stable task inputs</a> principle.
To use of the build cache effectively, you should depend on fixed dependencies.
You may want to look into the <a href="https://github.com/nebula-plugins/gradle-dependency-lock-plugin">dependency lock plugin</a> or switch to using <a href="https://docs.gradle.org/4.0-rc-2/userguide/composite_builds.html">composite builds</a> instead.</p>
</div>
<div class="paragraph">
<p>The same is true for depending on volatile external resources, for example a list of released versions.
One way of locking the changes would be to check the volatile resource into source control whenever it changes so that the builds only depend on the state in source control and not on the volatile resource itself.</p>
</div>
</div>
<div class="sect2">
<h3 id="suggestions_for_authoring_your_build"><a class="anchor" href="#suggestions_for_authoring_your_build"></a>6.7. Suggestions for authoring your build</h3>
<div class="sect3">
<h4 id="custom_actions"><a class="anchor" href="#custom_actions"></a>6.7.1. Review usages of <code>doFirst</code> and <code>doLast</code></h4>
<div class="paragraph">
<p>Using <code>doFirst</code> and <code>doLast</code> from a build script on a cacheable tasks ties you to build script changes since the implementation of the closure comes from the build script.
If possible, you should use separate tasks instead.</p>
</div>
<div class="paragraph">
<p>Modifying input or output properties via the runtime API in <code>doFirst</code> is discouraged since these changes will not be detected for up-to-date checks and the build cache.
Even worse, when the task does not execute, then the configuration of the task is actually different from when it executes.
Instead of using <code>doFirst</code> for modifying the inputs consider using a separate tasks to configure the task under question - a so called configure task.
E.g., instead of doing</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">jar {
    doFirst {
        jar.manifest.mainAttributes(<span class="string"><span class="delimiter">'</span><span class="content">Class-Path</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>project(<span class="string"><span class="delimiter">'</span><span class="content">:core</span><span class="delimiter">'</span></span>).jar.archivePath.name<span class="inline-delimiter">}</span></span><span class="content"> </span><span class="inline"><span class="inline-delimiter">${</span>project(<span class="string"><span class="delimiter">'</span><span class="content">:baseServices</span><span class="delimiter">'</span></span>).jar.archivePath.name<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>do</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task configureJar {
    doLast {
        jar.manifest.mainAttributes(<span class="string"><span class="delimiter">'</span><span class="content">Class-Path</span><span class="delimiter">'</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="inline"><span class="inline-delimiter">${</span>project(<span class="string"><span class="delimiter">'</span><span class="content">:core</span><span class="delimiter">'</span></span>).jar.archivePath.name<span class="inline-delimiter">}</span></span><span class="content"> </span><span class="inline"><span class="inline-delimiter">${</span>project(<span class="string"><span class="delimiter">'</span><span class="content">:baseServices</span><span class="delimiter">'</span></span>).jar.archivePath.name<span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>)
    }
}

jar.dependsOn(configureJar)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="logic_based_on_task_outcome"><a class="anchor" href="#logic_based_on_task_outcome"></a>6.7.2. Build logic based on the outcome of a task</h4>
<div class="paragraph">
<p>Do not base build logic on whether a task has been <em>executed</em>.
In particular you should not assume that the output of a task can only change if it actually executed.
Actually, loading the outputs from the build cache would also change them.
Instead of relying on custom logic to deal with changes to input or output files you should leverage Gradle&#8217;s built-in support by declaring the correct inputs and outputs for your tasks and leave it to Gradle to decide if the task actions should be executed.
For the very same reason using <code>outputs.upToDateWhen</code> is discouraged and should be replaced by properly declaring the task&#8217;s inputs.</p>
</div>
</div>
<div class="sect3">
<h4 id="overlapping_outputs"><a class="anchor" href="#overlapping_outputs"></a>6.7.3. Overlapping outputs</h4>
<div class="paragraph">
<p>You already saw that overlapping outputs are a problem for task output caching in <a href="#concepts_overlapping_outputs">The case against overlapping outputs</a>.
When you add new tasks to your build or re-configure built-in tasks make sure you do not create overlapping outputs for cacheable tasks.
If you must you can add a <code>Sync</code> task which then would sync the merged outputs into the target directory while the original tasks remain cacheable.</p>
</div>
<div class="paragraph">
<p>Gradle Enterprise will show tasks where caching was disabled for overlapping outputs in the timeline and in the task input comparison:</p>
</div>
<div class="imageblock screenshot">
<div class="content">
<img src="images/overlapping-outputs-input-comparison.png" alt="overlapping outputs input comparison">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="achieving_stable_task_inputs"><a class="anchor" href="#achieving_stable_task_inputs"></a>6.8. Achieving stable task inputs</h3>
<div class="paragraph">
<p>It is crucial to have <a href="#stable_task_inputs">stable task inputs</a> for every cacheable task.
We will go through various situations which violate stable task inputs and look at possible solutions.</p>
</div>
<div class="sect3">
<h4 id="volatile_inputs"><a class="anchor" href="#volatile_inputs"></a>6.8.1. Volatile task inputs</h4>
<div class="paragraph">
<p>If you use a volatile input like a timestamp as an input property for a task, then there is nothing Gradle can do to make the task cacheable.
You should really think hard if the volatile data is really essential to the output or if it is only there for e.g. auditing purposes.</p>
</div>
<div class="paragraph">
<p>If the volatile input is essential to the output then you can try to make the task using the volatile input cheaper to execute.
You can do this by splitting the task into two tasks - the first task doing the expensive work which is cacheable and the second task adding the volatile data to the output.
In this way the output stays the same and the build cache can be used to avoid doing the expensive work.
For example, for building a jar file the expensive part - Java compilation - is already a different task while the jar task itself, which is not cacheable, is cheap.</p>
</div>
<div class="paragraph">
<p>If it is not an essential part of the output, then you should not declare it as an input.
As long as the volatile input does not influence the output then there is nothing else to do.
Most times though, the input will be part of the output.</p>
</div>
</div>
<div class="sect3">
<h4 id="volatile_outputs"><a class="anchor" href="#volatile_outputs"></a>6.8.2. Non-repeatable task outputs</h4>
<div class="paragraph">
<p>Having tasks which generate different outputs for the same inputs can pose a challenge for the effective use of task output caching as seen in <a href="#concepts_repeatable_task_outputs">Repeatable task outputs</a>.
If the non-repeatable task output is not used by any other task then the effect is very limited.
It basically means that pulling the task from the cache might produce a different result than executing the same task locally.
If the only difference between the outputs is a timestamp, then you can either accept the effect of the build cache or decide that the task is not cacheable after all.</p>
</div>
<div class="paragraph">
<p>Non-repeatable task outputs lead to non-stable task inputs as soon as another task depends on the non-repeatable output.
For example, re-creating a jar file from the files with the same contents but different modification times yields a different jar file.
Any other task depending on this jar file as an input file cannot be loaded from the cache when the jar file is rebuilt locally.
This can lead to hard-to-diagnose cache misses when the consuming build is not a clean build or when a cacheable task depends on the output of a non-cacheable task.
For example, when doing incremental builds it is possible that the artifact on disk which is considered up-to-date and the artifact in the build cache are different even though they are essentially the same.
A task depending on this task output would then not be able to load outputs from the build cache since the inputs are not exactly the same.</p>
</div>
<div class="paragraph">
<p>As described <a href="#stable_task_inputs">earlier</a> you can either make the task outputs repeatable or use input normalization.</p>
</div>
<div class="paragraph">
<p>We already talked about the possibilities with input normalization and the possibility to configure input normalization.</p>
</div>
<div class="paragraph">
<p>Gradle includes some support for creating repeatable output for archive tasks.
For tar and zip files Gradle can be configured to create <a href="https://docs.gradle.org/4.0-rc-2/userguide/working_with_files.html#sec:reproducible_archives">reproducible archives</a>.
This is done by configuring e.g. the <code>Zip</code> task via the following snippet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">task createZip(<span class="key">type</span>: Zip) {
    preserveFileTimestamps = <span class="predefined-constant">false</span>
    reproducibleFileOrder = <span class="predefined-constant">true</span>
...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another way to make the outputs repeatable is to activate caching for a task with non-repeatable outputs.
If you can make sure that the same build cache is used for all builds then the task will always have the same outputs for the same inputs by design of the build cache.
Going down this road can lead to different problems with cache misses for incremental builds as described above.
Moreover, race conditions between different builds trying to store the same outputs in the build cache in parallel can lead to hard-to-diagnose cache misses.
If possible, you should avoid going down that route.</p>
</div>
</div>
<div class="sect3">
<h4 id="limit_the_effect_volative_data"><a class="anchor" href="#limit_the_effect_volative_data"></a>6.8.3. Limit the effect volative data</h4>
<div class="paragraph">
<p>If none of the described solutions for dealing with volatile data work for you, you should still be able to limit the effect of volatile data on effective use of the build cache.
This can be done by adding the volatile data later to the outputs as described in <a id="volatile_inputs"></a>.
Another option would be to move the volatile data so it affects less tasks.
For example moving the dependency from the <code>compile</code> to the <code>runtime</code> configuration may already have quite an impact.</p>
</div>
<div class="paragraph">
<p>Sometimes it is also possible to build two artifacts, one containing the volatile data and another one containing a constant representation of the volatile data.
The non-volatile output would be used e.g. for testing while the volatile one would be published to an external repository.
This is in conflict with the Continuous Delivery "build artifacts once" principle but can sometimes be the only option.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="custom_and_third_party_tasks"><a class="anchor" href="#custom_and_third_party_tasks"></a>6.9. Custom and third party tasks</h3>
<div class="paragraph">
<p>If your build contains custom or third party tasks, you should take special care that these don&#8217;t influence the effectiveness of the build cache.
Special care should also be taken for code generation tasks which may not have <a href="#concepts_repeatable_task_outputs">repeatable task outputs</a>.
This can happen if the code generator includes e.g. a timestamp in the generated files or depends on the order of the input files.
Other pitfalls can be the use of `HashMap`s or other data structures without order guarantees in the task&#8217;s code.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Some third party plugins can even influence cacheability of Gradle&#8217;s built-in tasks.
This can happen if they add inputs like absolute paths or volatile data to tasks via the runtime API.
In the worst case this can lead to incorrect builds when the plugins try to depend on the <a href="#logic_based_on_task_outcome">outcome of a task</a> and do not take <code>FROM-CACHE</code> into account.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="summary"><a class="anchor" href="#summary"></a>7. Summary</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You learned about the two ways Gradle can avoid work and we showed you the concepts which make up a build which is effectively using task output caching.
You should now have the knowledge to adapt your own build so it can make effective use of the build cache.
By doing so, you will improve incremental build performance while having fast clean builds when using the build cache.
Remember, the best way to do work faster is to not do work that doesn’t need doing.</p>
</div>
<div class="paragraph">
<p>Be aware that your journey does not end here.
You should invest into keeping your build well behaved and check manually or automatically that you are still making effective use of the build cache.</p>
</div>
<div class="paragraph">
<p>The Gradle team&#8217;s journey does not end here either.
They will continue improving the build cache and give you more tools to make your builds even faster.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-06-12 08:10:14 UTC
</div>
</div>
</body>
</html>